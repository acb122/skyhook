import { NgZone } from '@angular/core';
import { invariant } from './invariant';
import { Subscription, ReplaySubject, BehaviorSubject } from 'rxjs';
import { TYPE_DYNAMIC } from '../tokens';
import { take, map, distinctUntilChanged, switchMapTo } from 'rxjs/operators';
import { areCollectsEqual } from '../utils/areCollectsEqual';
import { scheduleMicroTaskAfter } from './scheduleMicroTaskAfter';
export class Connection {
    constructor(factoryArgs, manager, skyhookZone, initialType) {
        this.factoryArgs = factoryArgs;
        this.manager = manager;
        this.skyhookZone = skyhookZone;
        /** A subject basically used to kick off any observables waiting for a type to be set via setType/setTypes */
        this.resolvedType$ = new ReplaySubject(1);
        /**
         * This one lives exactly as long as the connection.
         * It is responsible for disposing of the handlerConnector, and any internal listen() subscriptions.
         */
        this.subscriptionConnectionLifetime = new Subscription();
        this.onUpdate = () => {
            this.handlerConnector.reconnect();
        };
        this.handleChange = () => {
            this.collector$.next(this.handlerMonitor);
        };
        invariant(typeof manager === 'object', 
        // TODO: update this mini-documentation
        'Could not find the drag and drop manager in the context of %s. ' +
            'Make sure to wrap the top-level component of your app with DragDropContext. '
        // tslint:disable-next-line:max-line-length
        // 'Read more: ',
        );
        NgZone.assertNotInAngularZone();
        this.handlerMonitor = this.factoryArgs.createMonitor(this.manager);
        this.collector$ = new BehaviorSubject(this.handlerMonitor);
        this.handler = this.factoryArgs.createHandler(this.handlerMonitor);
        this.handlerConnector = this.factoryArgs.createConnector(this.manager.getBackend());
        // handlerConnector lives longer than any per-type subscription
        this.subscriptionConnectionLifetime.add(() => this.handlerConnector.receiveHandlerId(null));
        if (initialType && initialType !== TYPE_DYNAMIC) {
            this.setTypes(initialType);
        }
    }
    listen(mapFn) {
        // Listeners are generally around as long as the connection.
        // This isn't 100% true, but there is no way of knowing (even if you ref-count it)
        // when a component no longer needs it.
        return this.resolvedType$.pipe(
        // this ensures we don't start emitting values until there is a type resolved
        take(1), 
        // switch our attention to the incoming firehose of 'something changed' events
        switchMapTo(this.collector$), 
        // turn them into 'interesting state' via the monitor and a user-provided function
        map(mapFn), 
        // don't emit EVERY time the firehose says something changed, only when the interesting state changes
        distinctUntilChanged(areCollectsEqual), 
        // this schedules a single batch change detection run after all the listeners have heard their newest value
        // thus all changes resulting from subscriptions to this are caught by the
        // change detector.
        scheduleMicroTaskAfter(this.skyhookZone, this.onUpdate));
    }
    connect(fn) {
        const subscription = this.resolvedType$.pipe(take(1)).subscribe(() => {
            // must run inside skyhookZone, so things like timers firing after a long hover with touch backend
            // will cause change detection (via executing a macro or event task)
            this.skyhookZone.run(() => {
                fn(this.handlerConnector.hooks);
            });
        });
        // now chain this onto the connection's unsubscribe call.
        // just in case you destroy your component before setting a type on anything
        // i.e.:
        // conn without a type
        //     source = this.dnd.dragSource(null, { ... })
        // manually connect to the DOM, which won't handle the returned subscription like the directive does
        //     ngAfterViewInit() { this.source.connectDragSource(this.myDiv.nativeElement); }
        // never set a type
        // then destroy your component, the source, but not the connection request.
        //     ngOnDestroy() { this.source.unsubscribe(); }
        //
        // without this, you would have a hanging resolvedType$.pipe(take(1)) subscription
        // with this, it dies with the source's unsubscribe call.
        //
        // doesn't need this.subscriptionTypeLifetime, because pipe(take(1)) already does that
        this.subscriptionConnectionLifetime.add(subscription);
        return subscription;
    }
    connectDropTarget(node) {
        return this.connect(c => c.dropTarget(node));
    }
    connectDragSource(node, options) {
        return this.connect(c => c.dragSource(node, options));
    }
    connectDragPreview(node, options) {
        return this.connect(c => c.dragPreview(node, options));
    }
    setTypes(type) {
        // must run inside skyhookZone, so things like timers firing after a long hover with touch backend
        // will cause change detection (via executing a macro or event task)
        this.skyhookZone.run(() => {
            this.receiveType(type);
            this.resolvedType$.next(1);
        });
    }
    setType(type) {
        this.setTypes(type);
    }
    getHandlerId() {
        return this.handlerId;
    }
    receiveType(type) {
        if (type === this.currentType) {
            return;
        }
        NgZone.assertNotInAngularZone();
        this.currentType = type;
        if (this.subscriptionTypeLifetime) {
            this.subscriptionTypeLifetime.unsubscribe();
        }
        // console.debug('subscribed to ' + type.toString());
        this.subscriptionTypeLifetime = new Subscription();
        const { handlerId, unregister } = this.factoryArgs.registerHandler(type, this.handler, this.manager);
        this.handlerId = handlerId;
        this.handlerMonitor.receiveHandlerId(handlerId);
        this.handlerConnector.receiveHandlerId(handlerId);
        const globalMonitor = this.manager.getMonitor();
        const unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });
        this.subscriptionTypeLifetime.add(unsubscribe);
        this.subscriptionTypeLifetime.add(unregister);
        // this.subscriptionTypeLifetime.add(() => console.debug("unsubscribed from " + type.toString()));
    }
    unsubscribe() {
        if (this.subscriptionTypeLifetime) {
            this.subscriptionTypeLifetime.unsubscribe();
        }
        this.subscriptionConnectionLifetime.unsubscribe();
    }
    add(teardown) {
        return this.subscriptionConnectionLifetime.add(teardown);
    }
    get closed() {
        return (this.subscriptionConnectionLifetime &&
            this.subscriptionConnectionLifetime.closed);
    }
}
export const TargetConnection = Connection;
export const SourceConnection = Connection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGlvbi1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJlZG5heC9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXhDLE9BQU8sRUFDSCxZQUFZLEVBRVosYUFBYSxFQUNiLGVBQWUsRUFFbEIsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXpDLE9BQU8sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLG9CQUFvQixFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTlFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBWTdELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBa0JsRSxNQUFNLE9BQU8sVUFBVTtJQTRCbkIsWUFDWSxXQUE4QyxFQUM5QyxPQUF3QixFQUN4QixXQUFpQixFQUN6QixXQUF3QztRQUhoQyxnQkFBVyxHQUFYLFdBQVcsQ0FBbUM7UUFDOUMsWUFBTyxHQUFQLE9BQU8sQ0FBaUI7UUFDeEIsZ0JBQVcsR0FBWCxXQUFXLENBQU07UUF2QjdCLDZHQUE2RztRQUM1RixrQkFBYSxHQUFHLElBQUksYUFBYSxDQUFNLENBQUMsQ0FBQyxDQUFDO1FBYTNEOzs7V0FHRztRQUNLLG1DQUE4QixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFzRHBELGFBQVEsR0FBRyxHQUFHLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3RDLENBQUMsQ0FBQztRQTBHTSxpQkFBWSxHQUFHLEdBQUcsRUFBRTtZQUN4QixJQUFJLENBQUMs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QUMsOEJBQThCLENBQUMsTUFBTSxDQUM3QyxDQUFDO0lBQ04sQ0FBQztDQUNKO0FBbUJELE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHLFVBQStCLENBQUM7QUFDaEUsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQUcsVUFBK0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhY2tlbmQsIERyYWdEcm9wTWFuYWdlciB9IGZyb20gJ2RuZC1jb3JlJztcbmltcG9ydCB7IE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnLi9pbnZhcmlhbnQnO1xuaW1wb3J0IHsgVHlwZU9yVHlwZUFycmF5IH0gZnJvbSAnLi4vdHlwZS1pc2gnO1xuaW1wb3J0IHtcbiAgICBTdWJzY3JpcHRpb24sXG4gICAgT2JzZXJ2YWJsZSxcbiAgICBSZXBsYXlTdWJqZWN0LFxuICAgIEJlaGF2aW9yU3ViamVjdCxcbiAgICBUZWFyZG93bkxvZ2ljXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVFlQRV9EWU5BTUlDIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuaW1wb3J0IHsgdGFrZSwgbWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc3dpdGNoTWFwVG8gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IGFyZUNvbGxlY3RzRXF1YWwgfSBmcm9tICcuLi91dGlscy9hcmVDb2xsZWN0c0VxdWFsJztcblxuaW1wb3J0IHsgRHJvcFRhcmdldE1vbml0b3IgfSBmcm9tICcuLi90YXJnZXQtbW9uaXRvcic7XG5pbXBvcnQgeyBEcmFnU291cmNlTW9uaXRvciB9IGZyb20gJy4uL3NvdXJjZS1tb25pdG9yJztcbmltcG9ydCAqIGFzIHQgZnJvbSAnLi4vY29ubmVjdGlvbi10eXBlcyc7XG5pbXBvcnQge1xuICAgIERyb3BUYXJnZXRDb25uZWN0b3IsXG4gICAgRHJhZ1NvdXJjZUNvbm5lY3RvcixcbiAgICBEcmFnU291cmNlT3B0aW9ucyxcbiAgICBEcmFnUHJldmlld09wdGlvbnNcbn0gZnJvbSAnLi4vY29ubmVjdG9ycyc7XG5pbXBvcnQgeyBDb25uZWN0b3IgfSBmcm9tICcuL2NyZWF0ZVNvdXJjZUNvbm5lY3Rvcic7XG5pbXBvcnQgeyBzY2hlZHVsZU1pY3JvVGFza0FmdGVyIH0gZnJvbSAnLi9zY2hlZHVsZU1pY3JvVGFza0FmdGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBGYWN0b3J5QXJnczxUTW9uaXRvciwgVENvbm5lY3Rvcj4ge1xuICAgIGNyZWF0ZUhhbmRsZXI6IChoYW5kbGVyTW9uaXRvcjogYW55KSA9PiBhbnk7XG4gICAgY3JlYXRlTW9uaXRvcjogKG1hbmFnZXI6IERyYWdEcm9wTWFuYWdlcikgPT4gVE1vbml0b3I7XG4gICAgY3JlYXRlQ29ubmVjdG9yOiAoXG4gICAgICAgIGJhY2tlbmQ6IEJhY2tlbmRcbiAgICApID0+IENvbm5lY3RvcjxUQ29ubmVjdG9yPjtcbiAgICByZWdpc3RlckhhbmRsZXI6IChcbiAgICAgICAgdHlwZTogYW55LFxuICAgICAgICBoYW5kbGVyOiBhbnksXG4gICAgICAgIG1hbmFnZXI6IERyYWdEcm9wTWFuYWdlclxuICAgICkgPT4ge1xuICAgICAgICBoYW5kbGVySWQ6IGFueTtcbiAgICAgICAgdW5yZWdpc3RlcjogU3Vic2NyaXB0aW9uIHwgRnVuY3Rpb247XG4gICAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb248VE1vbml0b3IgZXh0ZW5kcyBEcmFnU291cmNlTW9uaXRvciB8IERyb3BUYXJnZXRNb25pdG9yLCBUQ29ubmVjdG9yPiB7XG4gICAgLy8gaW1tdXRhYmxlIGFmdGVyIGluc3RhbnRpYXRpb25cbiAgICBwcml2YXRlIHJlYWRvbmx5IGhhbmRsZXJNb25pdG9yOiBhbnk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBoYW5kbGVyQ29ubmVjdG9yOiBDb25uZWN0b3I8VENvbm5lY3Rvcj47XG4gICAgcHJpdmF0ZSByZWFkb25seSBoYW5kbGVyOiBhbnk7XG5cbiAgICAvKiogVGhlIHN0cmVhbSBvZiBhbGwgY2hhbmdlIGV2ZW50cyBmcm9tIHRoZSBpbnRlcm5hbCBzdWJzY3JpcHRpb24ncyBoYW5kbGVDaGFuZ2UgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbGxlY3RvciQ6IEJlaGF2aW9yU3ViamVjdDxUTW9uaXRvcj47XG4gICAgLyoqIEEgc3ViamVjdCBiYXNpY2FsbHkgdXNlZCB0byBraWNrIG9mZiBhbnkgb2JzZXJ2YWJsZXMgd2FpdGluZyBmb3IgYSB0eXBlIHRvIGJlIHNldCB2aWEgc2V0VHlwZS9zZXRUeXBlcyAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZWRUeXBlJCA9IG5ldyBSZXBsYXlTdWJqZWN0PGFueT4oMSk7XG5cbiAgICAvLyBtdXRhYmxlIHN0YXRlXG4gICAgcHJpdmF0ZSBjdXJyZW50VHlwZT86IFR5cGVPclR5cGVBcnJheTtcbiAgICBwcml2YXRlIGhhbmRsZXJJZDogYW55O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBvbmUgaXMgY3JlYXRlZCBhbmQgZGVzdHJveWVkIG9uY2UgcGVyIHR5cGUgb3IgbGlzdCBvZiB0eXBlcy5cbiAgICAgKiBCZWNhdXNlIGVhY2ggdGltZSB3ZSBjaGFuZ2UgdGhlIHR5cGUsIHdlIHVuc3Vic2NyaWJlIGZyb20gdGhlIGdsb2JhbCBzdGF0ZSBzdG9yYWdlIGFuZFxuICAgICAqIHJlLXN1YnNjcmliZSB3aXRoIHRoZSBuZXcgdHlwZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvblR5cGVMaWZldGltZT86IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb25lIGxpdmVzIGV4YWN0bHkgYXMgbG9uZyBhcyB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiBJdCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIHRoZSBoYW5kbGVyQ29ubmVjdG9yLCBhbmQgYW55IGludGVybmFsIGxpc3RlbigpIHN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb25Db25uZWN0aW9uTGlmZXRpbWUgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBmYWN0b3J5QXJnczogRmFjdG9yeUFyZ3M8VE1vbml0b3IsIFRDb25uZWN0b3I+LFxuICAgICAgICBwcml2YXRlIG1hbmFnZXI6IERyYWdEcm9wTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSBza3lob29rWm9uZTogWm9uZSxcbiAgICAgICAgaW5pdGlhbFR5cGU6IFR5cGVPclR5cGVBcnJheSB8IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICB0eXBlb2YgbWFuYWdlciA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyBtaW5pLWRvY3VtZW50YXRpb25cbiAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCB0aGUgZHJhZyBhbmQgZHJvcCBtYW5hZ2VyIGluIHRoZSBjb250ZXh0IG9mICVzLiAnICtcbiAgICAgICAgICAgICdNYWtlIHN1cmUgdG8gd3JhcCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudCBvZiB5b3VyIGFwcCB3aXRoIERyYWdEcm9wQ29udGV4dC4gJ1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICAgICAgLy8gJ1JlYWQgbW9yZTogJyxcbiAgICAgICAgKTtcbiAgICAgICAgTmdab25lLmFzc2VydE5vdEluQW5ndWxhclpvbmUoKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJNb25pdG9yID0gdGhpcy5mYWN0b3J5QXJncy5jcmVhdGVNb25pdG9yKHRoaXMubWFuYWdlcik7XG4gICAgICAgIHRoaXMuY29sbGVjdG9yJCA9IG5ldyBCZWhhdmlvclN1YmplY3QodGhpcy5oYW5kbGVyTW9uaXRvcik7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IHRoaXMuZmFjdG9yeUFyZ3MuY3JlYXRlSGFuZGxlcih0aGlzLmhhbmRsZXJNb25pdG9yKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyQ29ubmVjdG9yID0gdGhpcy5mYWN0b3J5QXJncy5jcmVhdGVDb25uZWN0b3IoXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZ2V0QmFja2VuZCgpXG4gICAgICAgICk7XG4gICAgICAgIC8vIGhhbmRsZXJDb25uZWN0b3IgbGl2ZXMgbG9uZ2VyIHRoYW4gYW55IHBlci10eXBlIHN1YnNjcmlwdGlvblxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNvbm5lY3Rpb25MaWZldGltZS5hZGQoKCkgPT5cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlckNvbm5lY3Rvci5yZWNlaXZlSGFuZGxlcklkKG51bGwpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGluaXRpYWxUeXBlICYmIGluaXRpYWxUeXBlICE9PSBUWVBFX0RZTkFNSUMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHlwZXMoaW5pdGlhbFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdGVuPFA+KG1hcEZuOiAobW9uaXRvcjogVE1vbml0b3IpID0+IFApOiBPYnNlcnZhYmxlPFA+IHtcbiAgICAgICAgLy8gTGlzdGVuZXJzIGFyZSBnZW5lcmFsbHkgYXJvdW5kIGFzIGxvbmcgYXMgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgMTAwJSB0cnVlLCBidXQgdGhlcmUgaXMgbm8gd2F5IG9mIGtub3dpbmcgKGV2ZW4gaWYgeW91IHJlZi1jb3VudCBpdClcbiAgICAgICAgLy8gd2hlbiBhIGNvbXBvbmVudCBubyBsb25nZXIgbmVlZHMgaXQuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZSQucGlwZShcbiAgICAgICAgICAgIC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBzdGFydCBlbWl0dGluZyB2YWx1ZXMgdW50aWwgdGhlcmUgaXMgYSB0eXBlIHJlc29sdmVkXG4gICAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgICAgLy8gc3dpdGNoIG91ciBhdHRlbnRpb24gdG8gdGhlIGluY29taW5nIGZpcmVob3NlIG9mICdzb21ldGhpbmcgY2hhbmdlZCcgZXZlbnRzXG4gICAgICAgICAgICBzd2l0Y2hNYXBUbyh0aGlzLmNvbGxlY3RvciQpLFxuICAgICAgICAgICAgLy8gdHVybiB0aGVtIGludG8gJ2ludGVyZXN0aW5nIHN0YXRlJyB2aWEgdGhlIG1vbml0b3IgYW5kIGEgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgICAgICAgbWFwKG1hcEZuKSxcbiAgICAgICAgICAgIC8vIGRvbid0IGVtaXQgRVZFUlkgdGltZSB0aGUgZmlyZWhvc2Ugc2F5cyBzb21ldGhpbmcgY2hhbmdlZCwgb25seSB3aGVuIHRoZSBpbnRlcmVzdGluZyBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChhcmVDb2xsZWN0c0VxdWFsKSxcbiAgICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgc2luZ2xlIGJhdGNoIGNoYW5nZSBkZXRlY3Rpb24gcnVuIGFmdGVyIGFsbCB0aGUgbGlzdGVuZXJzIGhhdmUgaGVhcmQgdGhlaXIgbmV3ZXN0IHZhbHVlXG4gICAgICAgICAgICAvLyB0aHVzIGFsbCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIHN1YnNjcmlwdGlvbnMgdG8gdGhpcyBhcmUgY2F1Z2h0IGJ5IHRoZVxuICAgICAgICAgICAgLy8gY2hhbmdlIGRldGVjdG9yLlxuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2tBZnRlcih0aGlzLnNreWhvb2tab25lLCB0aGlzLm9uVXBkYXRlKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlckNvbm5lY3Rvci5yZWNvbm5lY3QoKTtcbiAgICB9O1xuXG4gICAgY29ubmVjdChmbjogKGNvbm5lY3RvcjogVENvbm5lY3RvcikgPT4gdm9pZCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucmVzb2x2ZWRUeXBlJC5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBtdXN0IHJ1biBpbnNpZGUgc2t5aG9va1pvbmUsIHNvIHRoaW5ncyBsaWtlIHRpbWVycyBmaXJpbmcgYWZ0ZXIgYSBsb25nIGhvdmVyIHdpdGggdG91Y2ggYmFja2VuZFxuICAgICAgICAgICAgLy8gd2lsbCBjYXVzZSBjaGFuZ2UgZGV0ZWN0aW9uICh2aWEgZXhlY3V0aW5nIGEgbWFjcm8gb3IgZXZlbnQgdGFzaylcbiAgICAgICAgICAgIHRoaXMuc2t5aG9va1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmbih0aGlzLmhhbmRsZXJDb25uZWN0b3IuaG9va3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3cgY2hhaW4gdGhpcyBvbnRvIHRoZSBjb25uZWN0aW9uJ3MgdW5zdWJzY3JpYmUgY2FsbC5cbiAgICAgICAgLy8ganVzdCBpbiBjYXNlIHlvdSBkZXN0cm95IHlvdXIgY29tcG9uZW50IGJlZm9yZSBzZXR0aW5nIGEgdHlwZSBvbiBhbnl0aGluZ1xuICAgICAgICAvLyBpLmUuOlxuICAgICAgICAvLyBjb25uIHdpdGhvdXQgYSB0eXBlXG4gICAgICAgIC8vICAgICBzb3VyY2UgPSB0aGlzLmRuZC5kcmFnU291cmNlKG51bGwsIHsgLi4uIH0pXG4gICAgICAgIC8vIG1hbnVhbGx5IGNvbm5lY3QgdG8gdGhlIERPTSwgd2hpY2ggd29uJ3QgaGFuZGxlIHRoZSByZXR1cm5lZCBzdWJzY3JpcHRpb24gbGlrZSB0aGUgZGlyZWN0aXZlIGRvZXNcbiAgICAgICAgLy8gICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHsgdGhpcy5zb3VyY2UuY29ubmVjdERyYWdTb3VyY2UodGhpcy5teURpdi5uYXRpdmVFbGVtZW50KTsgfVxuICAgICAgICAvLyBuZXZlciBzZXQgYSB0eXBlXG4gICAgICAgIC8vIHRoZW4gZGVzdHJveSB5b3VyIGNvbXBvbmVudCwgdGhlIHNvdXJjZSwgYnV0IG5vdCB0aGUgY29ubmVjdGlvbiByZXF1ZXN0LlxuICAgICAgICAvLyAgICAgbmdPbkRlc3Ryb3koKSB7IHRoaXMuc291cmNlLnVuc3Vic2NyaWJlKCk7IH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gd2l0aG91dCB0aGlzLCB5b3Ugd291bGQgaGF2ZSBhIGhhbmdpbmcgcmVzb2x2ZWRUeXBlJC5waXBlKHRha2UoMSkpIHN1YnNjcmlwdGlvblxuICAgICAgICAvLyB3aXRoIHRoaXMsIGl0IGRpZXMgd2l0aCB0aGUgc291cmNlJ3MgdW5zdWJzY3JpYmUgY2FsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZG9lc24ndCBuZWVkIHRoaXMuc3Vic2NyaXB0aW9uVHlwZUxpZmV0aW1lLCBiZWNhdXNlIHBpcGUodGFrZSgxKSkgYWxyZWFkeSBkb2VzIHRoYXRcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25Db25uZWN0aW9uTGlmZXRpbWUuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfVxuXG4gICAgY29ubmVjdERyb3BUYXJnZXQobm9kZTogTm9kZSk6IFN1YnNjcmlwdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoYyA9PlxuICAgICAgICAgICAgKChjIGFzIGFueSkgYXMgRHJvcFRhcmdldENvbm5lY3RvcikuZHJvcFRhcmdldChub2RlKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbm5lY3REcmFnU291cmNlKFxuICAgICAgICBub2RlOiBOb2RlLFxuICAgICAgICBvcHRpb25zOiBEcmFnU291cmNlT3B0aW9uc1xuICAgICk6IFN1YnNjcmlwdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoYyA9PlxuICAgICAgICAgICAgKChjIGFzIGFueSkgYXMgRHJhZ1NvdXJjZUNvbm5lY3RvcikuZHJhZ1NvdXJjZShub2RlLCBvcHRpb25zKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbm5lY3REcmFnUHJldmlldyhcbiAgICAgICAgbm9kZTogTm9kZSxcbiAgICAgICAgb3B0aW9uczogRHJhZ1ByZXZpZXdPcHRpb25zXG4gICAgKTogU3Vic2NyaXB0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdChjID0+XG4gICAgICAgICAgICAoKGMgYXMgYW55KSBhcyBEcmFnU291cmNlQ29ubmVjdG9yKS5kcmFnUHJldmlldyhub2RlLCBvcHRpb25zKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldFR5cGVzKHR5cGU6IFR5cGVPclR5cGVBcnJheSkge1xuICAgICAgICAvLyBtdXN0IHJ1biBpbnNpZGUgc2t5aG9va1pvbmUsIHNvIHRoaW5ncyBsaWtlIHRpbWVycyBmaXJpbmcgYWZ0ZXIgYSBsb25nIGhvdmVyIHdpdGggdG91Y2ggYmFja2VuZFxuICAgICAgICAvLyB3aWxsIGNhdXNlIGNoYW5nZSBkZXRlY3Rpb24gKHZpYSBleGVjdXRpbmcgYSBtYWNybyBvciBldmVudCB0YXNrKVxuICAgICAgICB0aGlzLnNreWhvb2tab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVUeXBlKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUkLm5leHQoMSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFR5cGUodHlwZTogc3RyaW5nIHwgc3ltYm9sKSB7XG4gICAgICAgIHRoaXMuc2V0VHlwZXModHlwZSk7XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVySWQ7XG4gICAgfVxuXG4gICAgcmVjZWl2ZVR5cGUodHlwZTogVHlwZU9yVHlwZUFycmF5KSB7XG4gICAgICAgIGlmICh0eXBlID09PSB0aGlzLmN1cnJlbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSgpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFR5cGUgPSB0eXBlO1xuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblR5cGVMaWZldGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25UeXBlTGlmZXRpbWUudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmRlYnVnKCdzdWJzY3JpYmVkIHRvICcgKyB0eXBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblR5cGVMaWZldGltZSA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgICAgICBjb25zdCB7IGhhbmRsZXJJZCwgdW5yZWdpc3RlciB9ID0gdGhpcy5mYWN0b3J5QXJncy5yZWdpc3RlckhhbmRsZXIoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLFxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBoYW5kbGVySWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlck1vbml0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJDb25uZWN0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuXG4gICAgICAgIGNvbnN0IGdsb2JhbE1vbml0b3IgPSB0aGlzLm1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGdsb2JhbE1vbml0b3Iuc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAgICAgICAgeyBoYW5kbGVySWRzOiBbaGFuZGxlcklkXSB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25UeXBlTGlmZXRpbWUuYWRkKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25UeXBlTGlmZXRpbWUuYWRkKHVucmVnaXN0ZXIpO1xuICAgICAgICAvLyB0aGlzLnN1YnNjcmlwdGlvblR5cGVMaWZldGltZS5hZGQoKCkgPT4gY29uc29sZS5kZWJ1ZyhcInVuc3Vic2NyaWJlZCBmcm9tIFwiICsgdHlwZS50b1N0cmluZygpKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sbGVjdG9yJC5uZXh0KHRoaXMuaGFuZGxlck1vbml0b3IpO1xuICAgIH07XG5cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uVHlwZUxpZmV0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblR5cGVMaWZldGltZS51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ29ubmVjdGlvbkxpZmV0aW1lLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgYWRkKHRlYXJkb3duOiBUZWFyZG93bkxvZ2ljKTogU3Vic2NyaXB0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uQ29ubmVjdGlvbkxpZmV0aW1lLmFkZCh0ZWFyZG93bik7XG4gICAgfVxuXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ29ubmVjdGlvbkxpZmV0aW1lICYmXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNvbm5lY3Rpb25MaWZldGltZS5jbG9zZWRcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU291cmNlQ29uc3RydWN0b3I8SXRlbSA9IHt9LCBEcm9wUmVzdWx0ID0ge30+IHtcbiAgICBuZXcgKFxuICAgICAgICBmYWN0b3J5QXJnczogRmFjdG9yeUFyZ3M8RHJhZ1NvdXJjZU1vbml0b3IsIERyYWdTb3VyY2VDb25uZWN0b3I+LFxuICAgICAgICBtYW5hZ2VyOiBEcmFnRHJvcE1hbmFnZXIsXG4gICAgICAgIHNreWhvb2tab25lOiBab25lLFxuICAgICAgICBpbml0aWFsVHlwZTogc3RyaW5nIHwgc3ltYm9sIHwgdW5kZWZpbmVkXG4gICAgKTogdC5EcmFnU291cmNlPEl0ZW0sIERyb3BSZXN1bHQ+O1xufVxuZXhwb3J0IGludGVyZmFjZSBUYXJnZXRDb25zdHJ1Y3RvciB7XG4gICAgbmV3IChcbiAgICAgICAgZmFjdG9yeUFyZ3M6IEZhY3RvcnlBcmdzPERyb3BUYXJnZXRNb25pdG9yLCBEcm9wVGFyZ2V0Q29ubmVjdG9yPixcbiAgICAgICAgbWFuYWdlcjogRHJhZ0Ryb3BNYW5hZ2VyLFxuICAgICAgICBza3lob29rWm9uZTogWm9uZSxcbiAgICAgICAgaW5pdGlhbFR5cGU6IFR5cGVPclR5cGVBcnJheSB8IHVuZGVmaW5lZFxuICAgICk6IHQuRHJvcFRhcmdldDtcbn1cblxuZXhwb3J0IGNvbnN0IFRhcmdldENvbm5lY3Rpb24gPSBDb25uZWN0aW9uIGFzIFRhcmdldENvbnN0cnVjdG9yO1xuZXhwb3J0IGNvbnN0IFNvdXJjZUNvbm5lY3Rpb24gPSBDb25uZWN0aW9uIGFzIFNvdXJjZUNvbnN0cnVjdG9yO1xuIl19