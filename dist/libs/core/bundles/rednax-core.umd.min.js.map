{"version":3,"sources":["../../../../libs/core/src/lib/tokens.ts","../../../../libs/core/src/lib/utils/shallowEqual.ts","../../../../libs/core/src/lib/internal/Reconnector.ts","../../../../libs/core/src/lib/utils/areOptionsEqual.ts","../../../../libs/core/src/lib/internal/createTargetConnector.ts","../../../../libs/core/src/lib/internal/register-target.ts","../../../../libs/core/src/lib/internal/createSourceConnector.ts","../../../../libs/core/src/lib/internal/register-source.ts","../../../../libs/core/src/lib/internal/invariant.ts","../../../../libs/core/src/lib/utils/areCollectsEqual.ts","../../../../node_modules/tslib/tslib.es6.js","../../../../libs/core/src/lib/internal/scheduleMicroTaskAfter.ts","../../../../libs/core/src/lib/internal/connection-factory.ts","../../../../libs/core/src/lib/internal/drag-layer-connection.ts","../../../../libs/core/src/lib/internal/createSourceMonitor.ts","../../../../libs/core/src/lib/internal/createTargetFactory.ts","../../../../libs/core/src/lib/internal/createTargetMonitor.ts","../../../../libs/core/src/lib/internal/createSourceFactory.ts","../../../../libs/core/src/lib/connector.service.ts","../../../../libs/core/src/lib/dnd.directive.ts","../../../../libs/core/src/lib/dnd.module.ts"],"names":["DRAG_DROP_BACKEND","InjectionToken","DRAG_DROP_BACKEND_OPTIONS","DRAG_DROP_BACKEND_DEBUG_MODE","DRAG_DROP_MANAGER","DRAG_DROP_GLOBAL_CONTEXT","TYPE_DYNAMIC","Symbol","shallowEqual","objA","objB","keysA","Object","keys","keysB","length","hasOwn","prototype","hasOwnProperty","i","call","Reconnector","backendConnector","_this","this","reconnect","parentHandlerId","disconnect","handlerId","node","options","hook","nativeElement","nextOptions","currentOptions","TargetConnector","backend","dropTarget","connectDropTarget","hooks","receiveHandlerId","currentHandlerId","createTargetConnector","registerTarget","type","target","manager","registry","getRegistry","targetId","addTarget","unregister","removeTarget","SourceConnector","dragSource","connectDragSource","dragPreview","connectDragPreview","createSourceConnector","registerSource","source","sourceId","addSource","removeSource","invariant","assertion","msg","Error","areCollectsEqual","a","b","extendStatics","d","setPrototypeOf","__proto__","Array","p","__extends","__","constructor","create","__read","o","n","m","iterator","r","e","ar","next","done","push","value","error","__spread","arguments","concat","scheduleMicroTaskAfter","zone","uTask","lift","RunInZoneOperator","ZoneSubscriber","_super","destination","_next","val","scheduleMicroTask","Subscriber","subscriber","subscribe","Connection","factoryArgs","skyhookZone","initialType","resolvedType$","ReplaySubject","subscriptionConnectionLifetime","Subscription","onUpdate","handlerConnector","handleChange","collector$","handlerMonitor","NgZone","assertNotInAngularZone","createMonitor","BehaviorSubject","handler","createHandler","createConnector","getBackend","add","setTypes","listen","mapFn","pipe","take","switchMapTo","map","distinctUntilChanged","connect","fn","subscription","run","c","receiveType","setType","getHandlerId","currentType","subscriptionTypeLifetime","unsubscribe","_a","registerHandler","getMonitor","subscribeToStateChange","handlerIds","teardown","defineProperty","closed","TargetConnection","SourceConnection","DragLayerConnectionClass","isTicking","handleStateChange","monitor","handleOffsetChange","unsubscribeFromOffsetChange","subscribeToOffsetChange","unsubscribeFromStateChange","complete","isCallingCanDrag","isCallingIsDragging","DragSourceMonitorClass","internalMonitor","canDrag","canDragSource","isDragging","isDraggingSource","getItemType","getItem","getDropResult","didDrop","getInitialClientOffset","getInitialSourceClientOffset","getSourceClientOffset","getClientOffset","getDifferenceFromInitialOffset","createSourceMonitor","Target","spec","withChangeDetection","x","receiveMonitor","canDrop","hover","drop","isCallingCanDrop","DropTargetMonitorClass","canDropOnTarget","isOver","shallow","isOverTarget","createTargetMonitor","Source","globalMonitor","getSourceId","beginDrag","endDrag","SkyhookDndService","ngZone","Zone","root","fork","name","onHasTask","_parentZoneDelegate","_currentZone","_targetZone","state","change","types","createTarget","createTargetFactory","conn","createSource","createSourceFactory","dragLayer","i0","ɵɵinject","factory","ɵfac","DndDirective","elRef","deferredRequest","ngOnChanges","connection","isArray","runOutsideAngular","callHooks","ngOnDestroy","ɵɵdirectiveInject","ElementRef","selectors","features","ɵɵNgOnChangesFeature","DropTargetDirective","t","dropTargetTypes","inputs","dropTargetType","ɵɵInheritDefinitionFeature","DragSourceDirective","apply","noHTML5Preview","dragSourceType","sub","dragSourceOptions","emptyImage","Image","src","getEmptyImage","DragPreviewDirective","dragPreviewOptions","managerFactory","backendFactory","context","backendOptions","debugMode","default","createDragDropManager","getGlobalContext","global","window","SkyhookDndModule","forRoot","backendOrBackendFactory","ngModule","providers","provide","useValue","useFactory","debug","deps","declarations","exports"],"mappings":"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","sourcesContent":["/**\n * @module Misc\n */\n/** */\n\nimport { DragDropManager, Backend } from 'dnd-core';\nimport { InjectionToken } from '@angular/core';\n\n/** The injection token for the dnd-core compatible backend currently in use. */\nexport const DRAG_DROP_BACKEND = new InjectionToken<Backend>(\n    'dnd-core compatible backend'\n);\n\n/** The injection token for the dnd-core compatible backend's options. */\nexport const DRAG_DROP_BACKEND_OPTIONS = new InjectionToken<any>(\n    'options for dnd-core compatible backend'\n);\n\n/** The injection token for the dnd-core compatible backend currently in use. */\nexport const DRAG_DROP_BACKEND_DEBUG_MODE = new InjectionToken<any>(\n    'should dnd-core run in debug mode?'\n);\n\n/** The injection token for the dnd-core DragDropManager */\nexport const DRAG_DROP_MANAGER = new InjectionToken<DragDropManager>(\n    'dnd-core DragDropManager'\n);\n\n/** The injection token for the dnd-core compatible backend currently in use. */\nexport const DRAG_DROP_GLOBAL_CONTEXT = new InjectionToken<any>(\n    'dnd-core context'\n);\n\n/** The type a source or target is given as a marker for 'you supplied null as a type',\n *  so that library consumers can be reminded to use setType/setTypes manually.\n *  See {@link DragSource#setType}, {@link DropTarget#setTypes}.\n */\nexport const TYPE_DYNAMIC: symbol = Symbol(\n    'no type specified, you must provide one with setType/setTypes'\n);\n","export function shallowEqual(objA: any, objB: any) {\n  if (objA === objB) {\n    return true;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  const hasOwn = Object.prototype.hasOwnProperty;\n  for (let i = 0; i < keysA.length; i += 1) {\n    if (!hasOwn.call(objB, keysA[i]) ||\n        objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n\n    const valA = objA[keysA[i]];\n    const valB = objB[keysA[i]];\n\n    if (valA !== valB) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { Unsubscribe, Identifier } from 'dnd-core';\nimport areOptionsEqual from '../utils/areOptionsEqual';\n\nexport class Reconnector<O = any> {\n    handlerId: any;\n    node?: Node;\n    options?: O;\n    disconnect?: Unsubscribe | null;\n    constructor(\n        private backendConnector: (handlerId: any, node: Node, options?: O) => Unsubscribe\n    ) {}\n    reconnect = (parentHandlerId: Identifier | null) => {\n        if (this.disconnect) {\n            this.disconnect();\n            this.disconnect = null;\n        }\n        this.handlerId = parentHandlerId;\n        if (this.handlerId && this.node) {\n            this.disconnect = this.backendConnector(this.handlerId, this.node, this.options);\n        }\n    }\n    hook = (nativeElement: Node, options?: O) => {\n        if (nativeElement === this.node &&\n            areOptionsEqual(options, this.options)) {\n            return;\n        }\n\n        this.node = nativeElement;\n        this.options = options;\n\n        this.reconnect(this.handlerId);\n    }\n}\n","import { shallowEqual } from './shallowEqual';\n\nexport default function areOptionsEqual(nextOptions: any, currentOptions: any) {\n  if (currentOptions === nextOptions) {\n    return true;\n  }\n\n  return currentOptions !== null &&\n         nextOptions !== null &&\n         shallowEqual(currentOptions, nextOptions);\n}\n","import { Backend, Identifier } from 'dnd-core';\nimport { DropTargetConnector } from '../connectors';\nimport { Connector } from './createSourceConnector';\nimport { Reconnector } from './Reconnector';\n\nexport class TargetConnector implements Connector<DropTargetConnector> {\n    private currentHandlerId: any;\n\n    private dropTarget = new Reconnector<void>(\n        (handlerId, node, options) => {\n            return this.backend.connectDropTarget(handlerId, node, options);\n        }\n    );\n\n    constructor(private backend: Backend) {}\n\n    public receiveHandlerId(handlerId: Identifier | null) {\n        if (handlerId === this.currentHandlerId) {\n            return;\n        }\n        this.currentHandlerId = handlerId;\n        this.dropTarget.reconnect(handlerId);\n    }\n\n    public hooks: DropTargetConnector = {\n        dropTarget: this.dropTarget.hook\n    };\n\n    public reconnect() {\n        this.dropTarget.reconnect(this.currentHandlerId);\n    }\n}\n\nexport default function createTargetConnector(backend: Backend) {\n    return new TargetConnector(backend);\n}\n","import { DragDropManager, DropTarget } from 'dnd-core';\n\nexport default function registerTarget(type: any, target: DropTarget, manager: DragDropManager) {\n  const registry = manager.getRegistry();\n  const targetId = registry.addTarget(type, target);\n\n  function unregisterTarget() {\n    registry.removeTarget(targetId);\n  }\n\n  return {\n    handlerId: targetId,\n    unregister: unregisterTarget,\n  };\n}\n","import { Backend, Identifier } from 'dnd-core';\nimport { DragSourceConnector } from '../connectors';\nimport { Reconnector } from './Reconnector';\nimport { DragPreviewOptions, DragSourceOptions } from '../connectors'\n\nexport interface Connector<TConnector> {\n    hooks: TConnector;\n    receiveHandlerId(handlerId: Identifier | null): void;\n    reconnect(): void;\n}\n\nexport class SourceConnector implements Connector<DragSourceConnector> {\n    private currentHandlerId: any;\n\n    private dragSource = new Reconnector<DragSourceOptions>(\n        (handlerId, node, options) => {\n            return this.backend.connectDragSource(handlerId, node, options);\n        }\n    );\n    private dragPreview = new Reconnector<DragPreviewOptions>(\n        (handlerId, node, options) => {\n            return this.backend.connectDragPreview(handlerId, node, options);\n        }\n    );\n\n    constructor(private backend: Backend) {}\n\n    public receiveHandlerId(handlerId: Identifier | null) {\n        if (handlerId === this.currentHandlerId) {\n            return;\n        }\n        this.currentHandlerId = handlerId;\n        this.dragSource.reconnect(handlerId);\n        this.dragPreview.reconnect(handlerId);\n    }\n\n    public hooks: DragSourceConnector = {\n        dragSource: this.dragSource.hook,\n        dragPreview: this.dragPreview.hook,\n    };\n\n    public reconnect() {\n        this.dragSource.reconnect(this.currentHandlerId);\n        this.dragPreview.reconnect(this.currentHandlerId);\n    }\n}\n\nexport default function createSourceConnector(backend: Backend) {\n    return new SourceConnector(backend);\n}\n","import { DragDropManager, DragSource } from 'dnd-core';\n\nexport default function registerSource(type: any, source: DragSource, manager: DragDropManager) {\n  const registry = manager.getRegistry();\n  const sourceId = registry.addSource(type, source);\n\n  function unregisterSource() {\n    registry.removeSource(sourceId);\n  }\n\n  return {\n    handlerId: sourceId,\n    unregister: unregisterSource,\n  };\n}\n","export function invariant(assertion: boolean, msg: string) {\n  if (!assertion) {\n    throw new Error(msg);\n  }\n}\n\n","import { shallowEqual } from './shallowEqual';\n\nexport function areCollectsEqual(a: any, b: any) {\n  if (a == null || b == null) {\n    return false;\n  }\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  return shallowEqual(a, b);\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Observable, TeardownLogic, Subscriber, Operator } from 'rxjs';\n\n\n/**\n * @ignore\n * This is an RxJS operator to schedule a microtask just after all\n * the synchronous subscribers have been processed.\n * It's useful because we use `microTasks !== 0` to determine when we are finished\n * processing all the listeners and are ready for Angular to perform change detection.\n */\n\nexport function scheduleMicroTaskAfter<T>(zone: Zone, uTask?: () => void) {\n    return (source: Observable<T>): Observable<T> => {\n        return source.lift(new RunInZoneOperator(zone, uTask));\n    };\n}\n\n/**\n * @ignore\n */\nexport class ZoneSubscriber<T> extends Subscriber<T> {\n    constructor(destination: Subscriber<T>, private zone: Zone, private uTask: () => void = (() => {})) {\n        super(destination);\n    }\n    protected _next(val: T) {\n        this.destination.next && this.destination.next(val);\n        this.zone.scheduleMicroTask('ZoneSubscriber', this.uTask);\n    }\n}\n\n/**\n * @ignore\n */\nexport class RunInZoneOperator<T, R> implements Operator<T, R> {\n    constructor(private zone: Zone, private uTask?: () => void) { }\n    call(subscriber: Subscriber<R>, source: any): TeardownLogic {\n        return source.subscribe(new ZoneSubscriber(subscriber, this.zone, this.uTask));\n    }\n}\n","import { Backend, DragDropManager } from 'dnd-core';\nimport { NgZone } from '@angular/core';\nimport { invariant } from './invariant';\nimport { TypeOrTypeArray } from '../type-ish';\nimport {\n    Subscription,\n    Observable,\n    ReplaySubject,\n    BehaviorSubject,\n    TeardownLogic\n} from 'rxjs';\nimport { TYPE_DYNAMIC } from '../tokens';\n\nimport { take, map, distinctUntilChanged, switchMapTo } from 'rxjs/operators';\n\nimport { areCollectsEqual } from '../utils/areCollectsEqual';\n\nimport { DropTargetMonitor } from '../target-monitor';\nimport { DragSourceMonitor } from '../source-monitor';\nimport * as t from '../connection-types';\nimport {\n    DropTargetConnector,\n    DragSourceConnector,\n    DragSourceOptions,\n    DragPreviewOptions\n} from '../connectors';\nimport { Connector } from './createSourceConnector';\nimport { scheduleMicroTaskAfter } from './scheduleMicroTaskAfter';\n\nexport interface FactoryArgs<TMonitor, TConnector> {\n    createHandler: (handlerMonitor: any) => any;\n    createMonitor: (manager: DragDropManager) => TMonitor;\n    createConnector: (\n        backend: Backend\n    ) => Connector<TConnector>;\n    registerHandler: (\n        type: any,\n        handler: any,\n        manager: DragDropManager\n    ) => {\n        handlerId: any;\n        unregister: Subscription | Function;\n    };\n}\n\nexport class Connection<TMonitor extends DragSourceMonitor | DropTargetMonitor, TConnector> {\n    // immutable after instantiation\n    private readonly handlerMonitor: any;\n    private readonly handlerConnector: Connector<TConnector>;\n    private readonly handler: any;\n\n    /** The stream of all change events from the internal subscription's handleChange */\n    private readonly collector$: BehaviorSubject<TMonitor>;\n    /** A subject basically used to kick off any observables waiting for a type to be set via setType/setTypes */\n    private readonly resolvedType$ = new ReplaySubject<any>(1);\n\n    // mutable state\n    private currentType?: TypeOrTypeArray;\n    private handlerId: any;\n\n    /**\n     * This one is created and destroyed once per type or list of types.\n     * Because each time we change the type, we unsubscribe from the global state storage and\n     * re-subscribe with the new type.\n     */\n    private subscriptionTypeLifetime?: Subscription;\n\n    /**\n     * This one lives exactly as long as the connection.\n     * It is responsible for disposing of the handlerConnector, and any internal listen() subscriptions.\n     */\n    private subscriptionConnectionLifetime = new Subscription();\n\n    constructor(\n        private factoryArgs: FactoryArgs<TMonitor, TConnector>,\n        private manager: DragDropManager,\n        private skyhookZone: Zone,\n        initialType: TypeOrTypeArray | undefined\n    ) {\n        invariant(\n            typeof manager === 'object',\n            // TODO: update this mini-documentation\n            'Could not find the drag and drop manager in the context of %s. ' +\n            'Make sure to wrap the top-level component of your app with DragDropContext. '\n            // tslint:disable-next-line:max-line-length\n            // 'Read more: ',\n        );\n        NgZone.assertNotInAngularZone();\n\n        this.handlerMonitor = this.factoryArgs.createMonitor(this.manager);\n        this.collector$ = new BehaviorSubject(this.handlerMonitor);\n        this.handler = this.factoryArgs.createHandler(this.handlerMonitor);\n        this.handlerConnector = this.factoryArgs.createConnector(\n            this.manager.getBackend()\n        );\n        // handlerConnector lives longer than any per-type subscription\n        this.subscriptionConnectionLifetime.add(() =>\n            this.handlerConnector.receiveHandlerId(null)\n        );\n\n        if (initialType && initialType !== TYPE_DYNAMIC) {\n            this.setTypes(initialType);\n        }\n    }\n\n    listen<P>(mapFn: (monitor: TMonitor) => P): Observable<P> {\n        // Listeners are generally around as long as the connection.\n        // This isn't 100% true, but there is no way of knowing (even if you ref-count it)\n        // when a component no longer needs it.\n        return this.resolvedType$.pipe(\n            // this ensures we don't start emitting values until there is a type resolved\n            take(1),\n            // switch our attention to the incoming firehose of 'something changed' events\n            switchMapTo(this.collector$),\n            // turn them into 'interesting state' via the monitor and a user-provided function\n            map(mapFn),\n            // don't emit EVERY time the firehose says something changed, only when the interesting state changes\n            distinctUntilChanged(areCollectsEqual),\n            // this schedules a single batch change detection run after all the listeners have heard their newest value\n            // thus all changes resulting from subscriptions to this are caught by the\n            // change detector.\n            scheduleMicroTaskAfter(this.skyhookZone, this.onUpdate)\n        );\n    }\n\n    private onUpdate = () => {\n        this.handlerConnector.reconnect();\n    };\n\n    connect(fn: (connector: TConnector) => void): Subscription {\n        const subscription = this.resolvedType$.pipe(take(1)).subscribe(() => {\n            // must run inside skyhookZone, so things like timers firing after a long hover with touch backend\n            // will cause change detection (via executing a macro or event task)\n            this.skyhookZone.run(() => {\n                fn(this.handlerConnector.hooks);\n            });\n        });\n        // now chain this onto the connection's unsubscribe call.\n        // just in case you destroy your component before setting a type on anything\n        // i.e.:\n        // conn without a type\n        //     source = this.dnd.dragSource(null, { ... })\n        // manually connect to the DOM, which won't handle the returned subscription like the directive does\n        //     ngAfterViewInit() { this.source.connectDragSource(this.myDiv.nativeElement); }\n        // never set a type\n        // then destroy your component, the source, but not the connection request.\n        //     ngOnDestroy() { this.source.unsubscribe(); }\n        //\n        // without this, you would have a hanging resolvedType$.pipe(take(1)) subscription\n        // with this, it dies with the source's unsubscribe call.\n        //\n        // doesn't need this.subscriptionTypeLifetime, because pipe(take(1)) already does that\n        this.subscriptionConnectionLifetime.add(subscription);\n        return subscription;\n    }\n\n    connectDropTarget(node: Node): Subscription {\n        return this.connect(c =>\n            ((c as any) as DropTargetConnector).dropTarget(node)\n        );\n    }\n\n    connectDragSource(\n        node: Node,\n        options: DragSourceOptions\n    ): Subscription {\n        return this.connect(c =>\n            ((c as any) as DragSourceConnector).dragSource(node, options)\n        );\n    }\n\n    connectDragPreview(\n        node: Node,\n        options: DragPreviewOptions\n    ): Subscription {\n        return this.connect(c =>\n            ((c as any) as DragSourceConnector).dragPreview(node, options)\n        );\n    }\n\n    setTypes(type: TypeOrTypeArray) {\n        // must run inside skyhookZone, so things like timers firing after a long hover with touch backend\n        // will cause change detection (via executing a macro or event task)\n        this.skyhookZone.run(() => {\n            this.receiveType(type);\n            this.resolvedType$.next(1);\n        });\n    }\n\n    setType(type: string | symbol) {\n        this.setTypes(type);\n    }\n\n    getHandlerId() {\n        return this.handlerId;\n    }\n\n    receiveType(type: TypeOrTypeArray) {\n        if (type === this.currentType) {\n            return;\n        }\n\n        NgZone.assertNotInAngularZone();\n\n        this.currentType = type;\n\n        if (this.subscriptionTypeLifetime) {\n            this.subscriptionTypeLifetime.unsubscribe();\n        }\n        // console.debug('subscribed to ' + type.toString());\n        this.subscriptionTypeLifetime = new Subscription();\n\n        const { handlerId, unregister } = this.factoryArgs.registerHandler(\n            type,\n            this.handler,\n            this.manager\n        );\n\n        this.handlerId = handlerId;\n        this.handlerMonitor.receiveHandlerId(handlerId);\n        this.handlerConnector.receiveHandlerId(handlerId);\n\n        const globalMonitor = this.manager.getMonitor();\n        const unsubscribe = globalMonitor.subscribeToStateChange(\n            this.handleChange,\n            { handlerIds: [handlerId] }\n        );\n\n        this.subscriptionTypeLifetime.add(unsubscribe);\n        this.subscriptionTypeLifetime.add(unregister);\n        // this.subscriptionTypeLifetime.add(() => console.debug(\"unsubscribed from \" + type.toString()));\n    }\n\n    private handleChange = () => {\n        this.collector$.next(this.handlerMonitor);\n    };\n\n    unsubscribe() {\n        if (this.subscriptionTypeLifetime) {\n            this.subscriptionTypeLifetime.unsubscribe();\n        }\n        this.subscriptionConnectionLifetime.unsubscribe();\n    }\n\n    add(teardown: TeardownLogic): Subscription {\n        return this.subscriptionConnectionLifetime.add(teardown);\n    }\n\n    get closed() {\n        return (\n            this.subscriptionConnectionLifetime &&\n            this.subscriptionConnectionLifetime.closed\n        );\n    }\n}\n\nexport interface SourceConstructor<Item = {}, DropResult = {}> {\n    new (\n        factoryArgs: FactoryArgs<DragSourceMonitor, DragSourceConnector>,\n        manager: DragDropManager,\n        skyhookZone: Zone,\n        initialType: string | symbol | undefined\n    ): t.DragSource<Item, DropResult>;\n}\nexport interface TargetConstructor {\n    new (\n        factoryArgs: FactoryArgs<DropTargetMonitor, DropTargetConnector>,\n        manager: DragDropManager,\n        skyhookZone: Zone,\n        initialType: TypeOrTypeArray | undefined\n    ): t.DropTarget;\n}\n\nexport const TargetConnection = Connection as TargetConstructor;\nexport const SourceConnection = Connection as SourceConstructor;\n","import { Subscription, Observable, BehaviorSubject, TeardownLogic } from 'rxjs';\nimport { DragDropManager, Unsubscribe } from 'dnd-core';\nimport { DragLayer } from '../connection-types';\nimport { DragLayerMonitor } from '../layer-monitor';\nimport { areCollectsEqual } from '../utils/areCollectsEqual';\nimport { map, distinctUntilChanged } from 'rxjs/operators';\nimport { scheduleMicroTaskAfter } from './scheduleMicroTaskAfter';\n\nexport class DragLayerConnectionClass implements DragLayer {\n\n  unsubscribeFromOffsetChange: Unsubscribe;\n  unsubscribeFromStateChange: Unsubscribe;\n  private readonly collector$: BehaviorSubject<DragLayerMonitor>;\n  private subscription = new Subscription();\n\n\n  constructor(private manager: DragDropManager, private zone: Zone) {\n    const monitor = this.manager.getMonitor();\n    this.collector$ = new BehaviorSubject<DragLayerMonitor>(monitor);\n    this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(\n      this.handleOffsetChange\n    );\n    this.unsubscribeFromStateChange = monitor.subscribeToStateChange(\n      this.handleStateChange\n    );\n\n    this.subscription.add(() => {\n      this.unsubscribeFromOffsetChange();\n      this.unsubscribeFromStateChange();\n    });\n\n    this.handleStateChange();\n  }\n\n  isTicking = false;\n\n  private handleStateChange = () => {\n    const monitor = this.manager.getMonitor() as DragLayerMonitor;\n    this.collector$.next(monitor);\n  }\n  private handleOffsetChange = () => {\n    const monitor = this.manager.getMonitor() as DragLayerMonitor;\n    this.collector$.next(monitor);\n  }\n\n  listen<P>(mapFn: (monitor: DragLayerMonitor) => P): Observable<P> {\n    return this.collector$.pipe(\n      map(mapFn),\n      distinctUntilChanged(areCollectsEqual),\n      scheduleMicroTaskAfter(this.zone)\n    );\n  }\n\n  unsubscribe() {\n    this.collector$.complete();\n    this.subscription.unsubscribe();\n  }\n\n  add(teardown: TeardownLogic): Subscription {\n    return this.subscription.add(teardown);\n  }\n\n  get closed() {\n    return this.subscription.closed;\n  }\n\n}\n\n","import { DragDropMonitor, Identifier } from 'dnd-core';\nimport { DragSourceMonitor } from '../source-monitor';\nimport { invariant } from './invariant';\n\nlet isCallingCanDrag = false;\nlet isCallingIsDragging = false;\n\n\nclass DragSourceMonitorClass implements DragSourceMonitor {\n    internalMonitor: DragDropMonitor;\n    sourceId: Identifier | undefined;\n\n    constructor(manager: any) {\n        this.internalMonitor = manager.getMonitor();\n    }\n\n    receiveHandlerId(sourceId: Identifier | undefined) {\n        this.sourceId = sourceId;\n    }\n\n    canDrag() {\n        invariant(\n            !isCallingCanDrag,\n            'You may not call monitor.canDrag() inside your canDrag() implementation. ' +\n            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html',\n        );\n\n        try {\n            isCallingCanDrag = true;\n            return this.internalMonitor.canDragSource(this.sourceId);\n        } finally {\n            isCallingCanDrag = false;\n        }\n    }\n\n    isDragging() {\n        invariant(\n            !isCallingIsDragging,\n            'You may not call monitor.isDragging() inside your isDragging() implementation. ' +\n            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html',\n        );\n\n        try {\n            isCallingIsDragging = true;\n            return this.internalMonitor.isDraggingSource(this.sourceId);\n        } finally {\n            isCallingIsDragging = false;\n        }\n    }\n\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n\n    getItem(): {} & any {\n        return this.internalMonitor.getItem();\n    }\n\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n}\n\nexport function createSourceMonitor(manager: any): DragSourceMonitor {\n    return new DragSourceMonitorClass(manager);\n}\n","import { DropTarget } from 'dnd-core';\nimport { DropTargetMonitor } from '../target-monitor';\nimport { DropTargetSpec } from '../drop-target-specification';\n\nexport class Target implements DropTarget {\n\n    constructor(\n        private spec: DropTargetSpec,\n        private zone: Zone,\n        private monitor: DropTargetMonitor\n    ) {\n        this.monitor = monitor;\n    }\n\n    withChangeDetection<T>(fn: () => T): T {\n        let x = fn();\n        this.zone.scheduleMicroTask('DropTarget', () => { });\n        return x;\n    }\n\n    receiveMonitor(monitor: any) {\n        this.monitor = monitor;\n    }\n\n    canDrop() {\n        if (!this.spec.canDrop) {\n            return true;\n        }\n\n        // don't run isDragging in the zone. Should be a pure function of `this`.\n        return this.spec.canDrop(this.monitor);\n    }\n\n    hover() {\n        if (!this.spec.hover) {\n            return;\n        }\n        this.withChangeDetection(() => {\n            this.spec.hover && this.spec.hover(this.monitor);\n        });\n    }\n\n    drop() {\n        if (!this.spec.drop) {\n            return undefined;\n        }\n\n        return this.withChangeDetection(() => {\n            const dropResult = this.spec.drop && this.spec.drop(this.monitor);\n            return dropResult;\n        });\n    }\n}\n\nexport function createTargetFactory(spec: DropTargetSpec, zone: Zone): any {\n    return function createTarget(monitor: any): DropTarget {\n        return new Target(spec, zone, monitor);\n    };\n}\n","import { invariant } from './invariant';\nimport { DragDropMonitor, Identifier } from 'dnd-core';\nimport { DropTargetMonitor } from '../target-monitor';\n\nlet isCallingCanDrop = false;\n\nclass DropTargetMonitorClass implements DropTargetMonitor {\n    internalMonitor: DragDropMonitor;\n    targetId: Identifier | undefined;\n\n    constructor(manager: any) {\n        this.internalMonitor = manager.getMonitor();\n    }\n\n    receiveHandlerId(targetId: Identifier | undefined) {\n        this.targetId = targetId;\n    }\n\n    canDrop(): boolean {\n        invariant(\n            !isCallingCanDrop,\n            'You may not call monitor.canDrop() inside your canDrop() implementation. ' +\n            'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html',\n        );\n\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally {\n            isCallingCanDrop = false;\n        }\n    }\n\n    isOver(options = { shallow: false }): boolean {\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n\n    getItem(): {} & any {\n        return this.internalMonitor.getItem();\n    }\n\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n\n    didDrop(): boolean {\n        return this.internalMonitor.didDrop();\n    }\n\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n}\n\nexport function createTargetMonitor(manager: any): DropTargetMonitor {\n    return new DropTargetMonitorClass(manager);\n}\n","import { DragSource } from 'dnd-core';\nimport { DragSourceSpec } from '../drag-source-specification';\nimport { DragSourceMonitor } from '../source-monitor';\n\nexport class Source implements DragSource {\n    constructor(\n        private spec: DragSourceSpec<any>,\n        private zone: Zone,\n        private monitor: DragSourceMonitor<any, any>,\n    ) {\n    }\n\n    withChangeDetection<T>(fn: () => T): T {\n        let x = fn()\n        this.zone.scheduleMicroTask('DragSource', () => { });\n        return x;\n    }\n\n    canDrag() {\n        if (!this.spec.canDrag) {\n            return true;\n        }\n\n        return this.withChangeDetection(() => {\n            return this.spec.canDrag && this.spec.canDrag(this.monitor) || false;\n        });\n    }\n\n    isDragging(globalMonitor: any, sourceId: any) {\n        if (!this.spec.isDragging) {\n            return sourceId === globalMonitor.getSourceId();\n        }\n\n        return this.spec.isDragging(this.monitor);\n    }\n\n    beginDrag() {\n        return this.withChangeDetection(() => {\n            return this.spec.beginDrag(this.monitor);\n        });\n    }\n\n    endDrag() {\n        if (!this.spec.endDrag) {\n            return;\n        }\n\n        return this.withChangeDetection(() => {\n            if (this.spec.endDrag) {\n                this.spec.endDrag(this.monitor);\n            }\n        });\n    }\n}\n\nexport function createSourceFactory(spec: DragSourceSpec<any>, zone: Zone) {\n    return function createSource(monitor: DragSourceMonitor): DragSource {\n        return new Source(spec, zone, monitor);\n    }\n}\n","/**\n * @module 1-Top-Level\n */\n/** a second comment */\n\n/// <reference types=\"zone.js\" />\nimport { Injectable, Inject, NgZone } from '@angular/core';\nimport { TYPE_DYNAMIC, DRAG_DROP_MANAGER } from './tokens';\nimport { DragDropManager } from 'dnd-core';\n\nimport { DropTargetSpec } from './drop-target-specification';\nimport createTargetConnector from './internal/createTargetConnector';\nimport registerTarget from './internal/register-target';\n\nimport { DragSourceSpec } from './drag-source-specification';\nimport createSourceConnector from './internal/createSourceConnector';\nimport registerSource from './internal/register-source';\n\nimport { SubscriptionLike, TeardownLogic } from 'rxjs';\nimport { TypeOrTypeArray } from './type-ish';\nimport {\n    // sourceConnectionFactory,\n    // targetConnectionFactory,\n    SourceConnection,\n    TargetConnection,\n} from './internal/connection-factory';\nimport { DragLayerConnectionClass } from './internal/drag-layer-connection';\n\nimport { DragSource, DropTarget, DragLayer } from './connection-types';\nimport { createSourceMonitor } from './internal/createSourceMonitor';\nimport { createTargetFactory } from './internal/createTargetFactory';\nimport { createTargetMonitor } from './internal/createTargetMonitor';\nimport { createSourceFactory } from './internal/createSourceFactory';\n\n/**\n * Represents an RxJS Subscription, with multi-version compatibility.\n * The standard SubscriptionLike does not contain an add() method.\n */\nexport interface AddSubscription extends SubscriptionLike {\n    /** Same as RxJS `Subscription#add` */\n    add(teardownLogic: TeardownLogic): AddSubscription;\n}\n\n/** For a simple component, unsubscribing is as easy as `connection.unsubscribe()` in `ngOnDestroy()`\n *  If your components have lots of subscriptions, it can get tedious having to\n *  unsubscribe from all of them, and you might forget. A common pattern is to create an RxJS Subscription\n *  (maybe called `destroy`), to use `this.destroy.add(xxx.subscribe(...))`\n *  and to call `destroy.unsubscribe()` once to clean up all of them. @rednax/core\n *  supports this pattern with by using the `subscription` parameter on the\n *  constructors. Simply:\n *\n```typescript\nimport { Subscription } from 'rxjs';\n// ...\ndestroy = new Subscription();\ntarget = this.dnd.dropTarget({\n  // ...\n}, this.destroy);\nngOnDestroy() { this.destroy.unsubscribe(); }\n```\n *\n * It is a good habit for avoiding leaked subscriptions, because .\n */\n\n@Injectable()\nexport class SkyhookDndService {\n    /** @ignore */\n    private skyhookZone: Zone = Zone.root.fork({\n        name: 'skyhookZone',\n        onHasTask: (_parentZoneDelegate, _currentZone, _targetZone, state) => {\n            // when we've | drained the microTask queue; or                    | ... run a change detection cycle.\n            //            | executed or cancelled a macroTask (eg a timer); or |\n            //            | handled an event                                   |\n\n            // note: we must use ngZone.run() instead of ApplicationRef.tick()\n            // this is because\n            // 1. this callback runs outside the angular zone\n            // 2. therefore if you use appRef.tick(), the event handlers set up during the tick() are\n            //    not in the angular zone, even though anything set up during tick() should be\n            // 3. therefore you get regular (click) handlers from templates running in skyhookZone\n            //    and not causing change detection\n\n            // Also, now we watch for macroTasks as well.\n            // This means if we set up timers in the skyhook zone, they will fire and cause change\n            // detection. Useful if doing .listen(...).delay(1000) and the resulting asynchronous\n            // subscribers.\n            // Appropriately, we run more setup handlers in skyhookZone now.\n            //\n            // Proper event handlers (set up by the backend) don't trigger any, because skyhookZone\n            // only cares about # of handlers changing => 0. But if we care about them, it will be\n            // through listen(), updates to which will schedule a microTask.\n\n            if (!state[state.change]) {\n                this.ngZone.run(() => {\n                    // noop, but causes change detection (i.e. onLeave)\n                });\n            }\n        },\n        // onInvokeTask: (zoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) => {\n        // }\n        // onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        //   return parentZoneDelegate.scheduleTask(targetZone, task);\n        // },\n        // onInvoke: (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) => {\n        // }\n    });\n\n    /** @ignore */\n    constructor(\n        @Inject(DRAG_DROP_MANAGER) private manager: DragDropManager,\n        private ngZone: NgZone\n    ) {}\n\n    /**\n     * This drop target will only react to the items produced by the drag sources\n     * of the specified type or types.\n     *\n     * If you want a dynamic type, pass `null` as the type; and call\n     * {@link DropTarget#setTypes} in a lifecycle hook.\n     */\n    public dropTarget<Item = {}, DropResult = {}>(\n        types: TypeOrTypeArray | null,\n        spec: DropTargetSpec<Item, DropResult>,\n        subscription?: AddSubscription\n    ): DropTarget<Item, DropResult> {\n        // return this.ngZone.runOutsideAngular(() => {\n        return this.skyhookZone.run(() => {\n            const createTarget: any = createTargetFactory(\n                spec,\n                this.skyhookZone\n            );\n\n            const conn: any = new TargetConnection(\n                {\n                    createHandler: createTarget,\n                    registerHandler: registerTarget,\n                    createMonitor: createTargetMonitor,\n                    createConnector: createTargetConnector,\n                },\n                this.manager,\n                this.skyhookZone,\n                types || TYPE_DYNAMIC\n            );\n\n            if (subscription) {\n                subscription.add(conn);\n            }\n            return conn;\n        });\n    }\n\n    /** This method creates a {@link DragSource} object. It represents a drag\n     *  source and its behaviour, and can be connected to a DOM element by\n     *  assigning it to the `[dragSource]` directive on that element in your\n     *  template.\n     *\n     * It is the corollary of [`react-dnd`'s\n     * `DragSource`](http://react-dnd.github.io/react-dnd/docs-drag-source.html).\n     *\n     * The `spec` argument ({@link DragSourceSpec}) is a set of _queries_ and\n     * _callbacks_ that are called at appropriate times by the internals. The\n     * queries are for asking your component whether to drag/listen and what\n     * item data to hoist up; the callback (just 1) is for notifying you when\n     * the drag ends.\n     *\n     * Only the drop targets registered for the same type will\n     * react to the items produced by this drag source. If you want a dynamic\n     * type, pass `null` as the type; and call {@link DragSource#setType} in\n     * a lifecycle hook.\n     *\n     * @param subscription An RxJS Subscription to tie the lifetime of the\n     * connection to.\n     */\n\n    public dragSource<Item, DropResult = {}>(\n        type: string | symbol | null,\n        spec: DragSourceSpec<Item, DropResult>,\n        subscription?: AddSubscription\n    ): DragSource<Item, DropResult> {\n        // return this.ngZone.runOutsideAngular(() => {\n        return this.skyhookZone.run(() => {\n            const createSource = createSourceFactory(spec, this.skyhookZone);\n            const conn = new SourceConnection(\n                {\n                    createHandler: createSource,\n                    registerHandler: registerSource,\n                    createMonitor: createSourceMonitor,\n                    createConnector: createSourceConnector,\n                },\n                this.manager,\n                this.skyhookZone,\n                type || TYPE_DYNAMIC\n            );\n            if (subscription) {\n                subscription.add(conn);\n            }\n            return conn;\n        });\n    }\n\n    /**\n     * This method creates a {@link DragLayer} object\n     */\n    public dragLayer<Item = any>(\n        subscription?: AddSubscription\n    ): DragLayer<Item> {\n        // return this.ngZone.runOutsideAngular(() => {\n        return this.skyhookZone.run(() => {\n            const conn = new DragLayerConnectionClass(\n                this.manager,\n                this.skyhookZone\n            );\n            if (subscription) {\n                subscription.add(conn);\n            }\n            return conn;\n        });\n    }\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone\n} from '@angular/core';\n\nimport { invariant } from './internal/invariant';\n\nimport { DropTarget, DragSource } from './connection-types';\nimport { DragSourceOptions, DragPreviewOptions } from './connectors';\nimport { Subscription } from 'rxjs';\nimport { TypeOrTypeArray } from './type-ish';\n\n/** @ignore */\nconst explanation =\n  'You can only pass exactly one connection object to [dropTarget]. ' +\n  'There is only one of each source/target/preview allowed per DOM element.'\n  ;\n\n/**\n * @ignore\n */\n@Directive({\n    selector: '[abstractDndDirective]'\n})\nexport class DndDirective {\n  protected connection: any;\n  private deferredRequest = new Subscription();\n  /** @ignore */\n  constructor(protected elRef: ElementRef, private zone: NgZone) { }\n  protected ngOnChanges() {\n    invariant(\n      typeof this.connection === 'object' && !Array.isArray(this.connection),\n      explanation\n    );\n    this.zone.runOutsideAngular(() => {\n      // discard an unresolved connection request\n      // in the case where the previous one succeeded, deferredRequest is\n      // already closed.\n      this.deferredRequest.unsubscribe();\n      // replace it with a new one\n      if (this.connection) {\n        this.deferredRequest = this.callHooks(this.connection);\n      }\n    });\n  }\n  protected ngOnDestroy() { this.deferredRequest.unsubscribe(); }\n  // @ts-ignore\n  protected callHooks(conn: any): Subscription {\n    return new Subscription();\n  }\n}\n\n// Note: the T | undefined everywhere is from https://github.com/angular/angular-cli/issues/2034\n\n/**\n * Allows you to connect a {@link DropTarget} to an element in a component template.\n */\n@Directive({\n  selector: '[dropTarget]'\n})\nexport class DropTargetDirective extends DndDirective {\n  protected connection: DropTarget | undefined;\n\n  /** Which target to connect the DOM to */\n  @Input('dropTarget') public dropTarget!: DropTarget;\n  /** Shortcut for setting a type on the connection.\n   *  Lets you use Angular binding to do it. Runs {@link DropTarget#setTypes}. */\n  @Input('dropTargetTypes') dropTargetTypes?: TypeOrTypeArray;\n  /** Reduce typo confusion by allowing non-plural version of dropTargetTypes */\n  @Input('dropTargetType') set dropTargetType(t: TypeOrTypeArray) {\n    this.dropTargetTypes = t;\n  }\n\n  protected ngOnChanges() {\n    this.connection = this.dropTarget;\n    if (this.connection && this.dropTargetTypes != null) {\n      this.connection.setTypes(this.dropTargetTypes);\n    }\n    super.ngOnChanges();\n  }\n\n  protected callHooks(conn: DropTarget): Subscription {\n    return conn.connectDropTarget(this.elRef.nativeElement);\n  }\n}\n\n/**\n * Allows you to connect a {@link DragSource} to an element in a component template.\n */\n@Directive({\n  selector: '[dragSource]'\n})\nexport class DragSourceDirective extends DndDirective {\n  protected connection: DragSource<any> | undefined;\n\n  /** Which source to connect the DOM to */\n  @Input('dragSource') dragSource!: DragSource<any>;\n  /** Shortcut for setting a type on the connection.\n   *  Lets you use Angular binding to do it. Runs {@link DragSource#setType}. */\n  @Input('dragSourceType') dragSourceType?: string | symbol;\n  /** Pass an options object as you would to {@link DragSource#connectDragSource}. */\n  @Input('dragSourceOptions') dragSourceOptions?: DragSourceOptions;\n  /** Do not render an HTML5 preview. Only applies when using the HTML5 backend.\n   * It does not use { captureDraggingState: true } for IE11 support; that is broken.\n   */\n  @Input('noHTML5Preview') noHTML5Preview = false;\n\n  protected ngOnChanges() {\n    this.connection = this.dragSource;\n    if (this.connection && this.dragSourceType != null) {\n      this.connection.setType(this.dragSourceType);\n    }\n    super.ngOnChanges();\n  }\n\n  protected callHooks(conn: DragSource<any>): Subscription {\n    const sub = new Subscription();\n    sub.add(conn.connectDragSource(this.elRef.nativeElement, this.dragSourceOptions));\n    if (this.noHTML5Preview) {\n      sub.add(conn.connectDragPreview(getEmptyImage()));\n    }\n    return sub;\n  }\n\n}\n\n/**\n * Allows you to specify which element a {@link DragSource} should screenshot as an HTML5 drag preview.\n *\n * Only relevant when using the HTML5 backend.\n */\n@Directive({\n  selector: '[dragPreview]',\n  inputs: ['dragPreview', 'dragPreviewOptions']\n})\nexport class DragPreviewDirective extends DndDirective {\n  protected connection: DragSource<any> | undefined;\n  /** The drag source for which this element will be the preview. */\n  @Input('dragPreview') public dragPreview!: DragSource<any>;\n  /** Pass an options object as you would to {@link DragSource#connectDragPreview}. */\n  @Input('dragPreviewOptions') dragPreviewOptions?: DragPreviewOptions;\n\n  protected ngOnChanges() {\n    this.connection = this.dragPreview;\n    super.ngOnChanges();\n  }\n\n  protected callHooks(conn: DragSource<any>) {\n    return conn.connectDragPreview(this.elRef.nativeElement, this.dragPreviewOptions);\n  }\n}\n\n// import { getEmptyImage } from 'react-dnd-html5-backend';\n// we don't want to depend on the backend, so here that is, copied\n/** @ignore */\nlet emptyImage: HTMLImageElement;\n/**\n * Returns a 0x0 empty GIF for use as a drag preview.\n * @ignore\n * */\nfunction getEmptyImage() {\n  if (!emptyImage) {\n    emptyImage = new Image();\n    emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n  }\n  return emptyImage;\n}\n\n","import { NgModule, ModuleWithProviders, NgZone } from '@angular/core';\n\nimport { SkyhookDndService } from './connector.service';\nimport {\n    DndDirective,\n    DragSourceDirective,\n    DropTargetDirective,\n    DragPreviewDirective,\n} from './dnd.directive';\n\nimport {\n    DRAG_DROP_BACKEND,\n    DRAG_DROP_BACKEND_OPTIONS,\n    DRAG_DROP_BACKEND_DEBUG_MODE,\n    DRAG_DROP_MANAGER,\n    DRAG_DROP_GLOBAL_CONTEXT,\n} from './tokens';\n\nimport {\n    createDragDropManager,\n    BackendFactory,\n    DragDropManager,\n} from 'dnd-core';\n\nimport { invariant } from './internal/invariant';\n\n/** @ignore */\nexport function unpackBackendForEs5Users(backendOrModule: any) {\n    // Auto-detect ES6 default export for people still using ES5\n    let backend = backendOrModule;\n    if (typeof backend === 'object' && typeof backend.default === 'function') {\n        backend = backend.default;\n    }\n    invariant(\n        typeof backend === 'function',\n        'Expected the backend to be a function or an ES6 module exporting a default function. ' +\n            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-drop-context.html'\n    );\n    return backend;\n}\n\n// TODO allow injecting window\n/** @ignore */\n// @dynamic\nexport function managerFactory(\n    backendFactory: BackendFactory,\n    zone: NgZone,\n    context: any,\n    backendOptions?: any,\n    debugMode?: boolean\n): DragDropManager {\n    backendFactory = unpackBackendForEs5Users(backendFactory);\n    return zone.runOutsideAngular(() =>\n        createDragDropManager(\n            backendFactory,\n            context,\n            backendOptions,\n            debugMode\n        )\n    );\n}\n\n/** @ignore */\ndeclare var global: any;\n/** @ignore */\nexport function getGlobalContext(): any {\n    return typeof global !== 'undefined' ? global : (window as any);\n}\n\n/*\n * Hold on, this gets a little confusing.\n *\n * A dnd-core Backend has lots of useful methods for registering elements and firing events.\n * However, backends are not distributed this way.\n * The HTML5Backend and the TestBackend, when imported { default as HTML5Backend }, are not Backends, they are\n * functions: (manager: DragDropManager) => Backend.\n * This is now known as a BackendFactory under dnd-core 4+ typescript annotations.\n *\n * However, Angular has its own conception of what a factory is for AOT. This is the 'factory'\n * to which BackendFactoryInput refers below.\n * Sometimes, users will want to preconfigure a backend (like TouchBackend, or MultiBackend).\n * For this, they need to export a function that returns a configured BackendFactory\n * and pass it in as  { backendFactory: exportedFunction }.\n */\n\n/** Use this for providing plain backends to {@link SkyhookDndModule#forRoot}. */\nexport interface BackendInput {\n    /** A plain backend, for example the HTML5Backend. */\n    backend: BackendFactory;\n    options?: any;\n    debug?: boolean;\n}\n\n/**\n * Use this for providing backends that need configuring before use to {@link SkyhookDndModule#forRoot}.\n *\n * For use with the MultiBackend:\n *\n * ```typescript\n * import { createDefaultMultiBackend } from '@rednax/multi-backend';\n * // ...\n * SkyhookDndModule.forRoot({ backendFactory: createDefaultMultiBackend })\n * ```\n *\n * or with the TouchBackend by itself:\n *\n * ```typescript\n * export function createTouchBackend() {\n *     return TouchBackend({ enableMouseEvents: false });\n * }\n * // ...\n * SkyhookDndModule.forRoot({ backendFactory: createTouchBackend })\n * ```\n *\n * You have to do this to retain AOT compatibility.\n */\nexport interface BackendFactoryInput {\n    /** See above. */\n    backendFactory: () => BackendFactory;\n    debug?: boolean;\n}\n\n/** @ignore */\nconst EXPORTS = [\n    DndDirective,\n    DragSourceDirective,\n    DropTargetDirective,\n    DragPreviewDirective,\n];\n\n// @dynamic\n@NgModule({\n    declarations: EXPORTS,\n    exports: EXPORTS,\n})\nexport class SkyhookDndModule {\n    static forRoot(\n        backendOrBackendFactory: BackendInput | BackendFactoryInput\n    ): ModuleWithProviders<any> {\n        return {\n            ngModule: SkyhookDndModule,\n            providers: [\n                {\n                    provide: DRAG_DROP_BACKEND,\n                    // whichever one they have provided, the other will be undefined\n                    useValue: (backendOrBackendFactory as BackendInput).backend,\n                    useFactory: (backendOrBackendFactory as BackendFactoryInput)\n                        .backendFactory,\n                },\n                {\n                    provide: DRAG_DROP_BACKEND_OPTIONS,\n                    // whichever one they have provided, the other will be undefined\n                    useValue: (backendOrBackendFactory as BackendInput).options,\n                },\n                {\n                    provide: DRAG_DROP_BACKEND_DEBUG_MODE,\n                    // whichever one they have provided, the other will be undefined\n                    useValue: backendOrBackendFactory.debug,\n                },\n                {\n                    provide: DRAG_DROP_GLOBAL_CONTEXT,\n                    useFactory: getGlobalContext,\n                },\n                {\n                    provide: DRAG_DROP_MANAGER,\n                    useFactory: managerFactory,\n                    deps: [\n                        DRAG_DROP_BACKEND,\n                        NgZone,\n                        DRAG_DROP_GLOBAL_CONTEXT,\n                        DRAG_DROP_BACKEND_OPTIONS,\n                        DRAG_DROP_BACKEND_DEBUG_MODE,\n                    ],\n                },\n                SkyhookDndService,\n            ],\n        };\n    }\n}\n"]}