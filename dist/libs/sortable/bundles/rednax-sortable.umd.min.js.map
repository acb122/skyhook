{"version":3,"sources":["../../../../libs/sortable/src/lib/types.ts","../../../../node_modules/tslib/tslib.es6.js","../../../../libs/sortable/src/lib/directives/sortable.directive.ts","../../../../libs/sortable/src/lib/isEmpty.ts","../../../../libs/sortable/src/lib/directives/template.directive.ts","../../../../libs/sortable/src/lib/directives/list.component.ts","../../../../libs/sortable/src/lib/hoverTriggers.ts","../../../../libs/sortable/src/lib/directives/render.directive.ts","../../../../libs/sortable/src/lib/ngrx-helpers.ts","../../../../libs/sortable/src/lib/directives/external.directive.ts","../../../../libs/sortable/src/lib/spillTarget.ts","../../../../libs/sortable/src/lib/module.ts"],"names":["HoverTrigger","Size","width","height","this","prototype","style","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","SkyhookSortable","dnd","el","cdr","_this","listId","Math","random","toString","horizontal","hoverTrigger","halfway","childrenSubject$","BehaviorSubject","children$","subs","Subscription","listSubs","target","dropTarget","canDrop","monitor","acceptsType","getItemType","item","getItem","getCanDrop","drop","spec","hover","children","list","list_1","list_1_1","isEmpty","isOver","shallow","callHover","index","updateSubscription","remove","unsubscribe","getList","cs$","subscribe","l","markForCheck","add","contextFor","data","_default","newHover","assign","ngOnInit","setTypes","getTargetType","isArray","accepts","type","ty","indexOf","ngOnChanges","_a","ngAfterViewInit","Error","connectDropTarget","nativeElement","ngOnDestroy","i0","ɵɵdirectiveInject","i1","SkyhookDndService","ElementRef","ChangeDetectorRef","selectors","inputs","exportAs","features","ɵɵNgOnChangesFeature","i0.ɵɵelementContainer","SkyhookSortableTemplate","i0.ɵɵelementContainerStart","i0.ɵɵtemplate","i0.ɵɵelementContainerEnd","i0.ɵɵadvance","i0.ɵɵproperty","ɵɵpureFunction1","_c0","ctx_r0","card_r1","i_r2","SkyhookSortableList","_super","trackById","_","trackBy","__","constructor","__extends","defineProperty","ql","template","first","ngAfterContentInit","changes","suggestHalfway","ctx","rect","clientOffset","dim","right","left","bottom","top","targetCentre","topHalf","x","y","suggestFixed","contentQueries","rf","dirIndex","TemplateRef","provide","useExisting","ɵɵInheritDefinitionFeature","decls","vars","consts","_scheduleMicroTaskPolyfill","requestAnimationFrame","webkitRequestAnimationFrame","f","setTimeout","SkyhookSortableRenderer","sameIds","other","source","dragSource","canDrag","getCanDrag","isDragging","beginDrag","createItem","endDrag","isDragging$","listen","context","size","isInternal","getClientOffset","suggestedIndex","trigger","fixed","getSuggester","suggester","getBoundingClientRect","setType","SortableEvents","EXTERNAL_LIST_ID","SkyhookSortableExternal","undefined","createData","event","BeginDrag","Hover","Drop","EndDrag","store","actionType","configure","_monitor","dispatch","BeginDragAction","HoverAction","DropAction","EndDragAction","SPILLED_LIST_ID","SkyhookSortableModule","imports","CommonModule","SkyhookDndModule","declarations","exports","types","config","mutate","hover$","Subject","didDrop","pipe","distinctUntilChanged","filter","a"],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs';\nimport { DropTargetMonitor, DragSourceMonitor } from '@rednax/core';\n\nexport interface SortableSpec<Data, Type = string | symbol> {\n    /** The underlying @rednax/core / dnd-core type.\n     * String or symbol, if that's not clear from the documentation output.. */\n    type: Type;\n\n    /** By default, a sortable accepts the type it produces. But you could have\n     * it accept more types. Be sure to include `type` if you want to sort a\n     * list within itself.\n     *\n     * This opens up other possibilities: if you set `type` to `\"A\"` but\n     * `accepts` to `\"B\"`, you could allow dragging `\"B\"`s into it but not\n     * sorting within the list. */\n    accepts?: string | symbol | (string | symbol)[];\n\n    /** Used for external data sources only.\n     *\n     * Must produce a new object, with some Data which will be unique for the given trackBy function. */\n    createData?(): Data;\n\n    /** Required. Must produce a different value for every available Data.\n     *  Usually, this will be `data => data.id`. */\n    trackBy(data: Data): any;\n\n    /** Optional if you provided `[ssSortableChildren],` otherwise required.\n     *  NOTE: return an Observable! If you don't have one already, use `[ssSortableChildren]`.\n     *  A typical use is with an @ngrx/store: `getList: _listId => this.store.select(...)` */\n    getList?(listId: any): Observable<Iterable<Data>>;\n\n    /** Optional; some implementations do not need beginDrag. */\n    beginDrag?(\n        item: DraggedItem<Data>,\n        monitor: DragSourceMonitor<void, void>\n    ): void;\n\n    /** Required.\n     *\n     * After `hover`, the element you picked up (= *transit*) must be:\n     *\n     * 1. under the mouse; and\n     * 2. at the index `item.hover.index` in the list identified by\n     *    `item.hover.listId`\n     */\n    hover(\n        item: DraggedItem<Data>,\n        monitor: DropTargetMonitor<DraggedItem<Data>>\n    ): void;\n\n    /** Required; because if you don't have a drop function, what are you even doing? */\n    drop(\n        item: DraggedItem<Data>,\n        monitor: DropTargetMonitor<DraggedItem<Data>>\n    ): void;\n\n    /** Required; you must reset and remove any temporarily added data from the drag. */\n    endDrag(\n        item: DraggedItem<Data>,\n        monitor: DragSourceMonitor<DraggedItem<Data>>\n    ): void;\n\n    /** Optional; you may override the default 'same trackBy' implementation.\n     *\n     * isDragging determines which card on the ground will regard itself as\n     * \"the same as the one in flight\". It must return true for exactly one\n     * card at a time, and that card MUST be placed under the most recently\n     * hovered DraggedItem.\n     *\n     * If it is not implemented correctly, then each card will not be able to\n     * determine whether it is under the mouse (and therefore should not emit\n     * hover events); you will get a deluge of incorrect hover events.\n     *\n     * By default, it is defined as:\n\n```typescript\ntrackBy(ground) === trackBy(inFlight.data)\n```\n\n     * If you want to be able to copy cards around, and there's an extra clone\n     * in transit around the board, you have to be careful to implement\n     * isDragging correctly, or ensure that any clones have a different\n     * `trackBy()` result. Note, however, that the item in `beginDrag` is the\n     * original, so simply giving clones a different `id` is not typically\n     * enough; the clone will not respond to `isDragging`, the original will\n     * (and you want to move the clone).\n     *\n     * Therefore, one solution is as follows:\n     *\n```typescript\nisDragging: (ground, inFlight) => {\n    let flyingId = this.isCopying ? CARD_ID_WHEN_COPYING : inFlight.data.id;\n    return ground.id === flyingId;\n}\n```\n     *\n     */\n    isDragging?(ground: Data, inFlight: DraggedItem<Data>): boolean;\n\n    /** Optional; you may override default `() => true`.\n     *\n     *  When used with the `[ssExternal]` directive, the first two arguments will be undefined,\n     *  because the data has not yet been created and external items are not associated with a list.\n     *  You should be able to decide `canDrag` without these.\n     */\n    canDrag?(\n        data: Data,\n        listId: any,\n        monitor: DragSourceMonitor<void, void>\n    ): boolean;\n\n    /** Optional; you may override default `() => true`.\n     *  Inspect `item.hover` for where it is hovering. */\n    canDrop?(\n        item: DraggedItem<Data>,\n        monitor: DropTargetMonitor<DraggedItem<Data>>\n    ): boolean;\n}\n\nexport class Size {\n    constructor(public width: number, public height: number) {}\n    style() {\n        return {\n            width: this.width + 'px',\n            height: this.height + 'px',\n        };\n    }\n}\n\nexport interface DraggedItem<Data> {\n    data: Data;\n    size: Size;\n    type: string | symbol;\n    index: number;\n    listId: any;\n    isInternal?: boolean;\n    // isCopy?: boolean;\n    hover: {\n        index: number;\n        listId: any;\n    };\n}\n\nexport enum HoverTrigger {\n    halfway = 'halfway',\n    fixed = 'fixed',\n}\n\nexport interface RenderContext<Data> {\n    data: Data;\n    index: number;\n    horizontal: boolean;\n    hoverTrigger: HoverTrigger;\n    listId: number;\n    spec: SortableSpec<Data>;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n    Input,\n    Directive,\n    OnInit,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    ElementRef,\n    SimpleChanges,\n    ChangeDetectorRef,\n} from '@angular/core';\n// @ts-ignore\nimport { Subscription, Observable, BehaviorSubject } from 'rxjs';\nimport { DropTarget, SkyhookDndService, DropTargetMonitor } from '@rednax/core';\nimport {\n    SortableSpec,\n    DraggedItem,\n    RenderContext,\n    HoverTrigger,\n} from '../types';\nimport { isEmpty } from '../isEmpty';\n\n@Directive({\n    selector: '[ssSortable]',\n    exportAs: 'ssSortable',\n})\nexport class SkyhookSortable<Data>\n    implements OnInit, OnChanges, OnDestroy, AfterViewInit {\n    @Input('ssSortableListId') listId: any = Math.random().toString();\n    @Input('ssSortableHorizontal') horizontal = false;\n    @Input('ssSortableSpec') protected spec!: SortableSpec<Data>;\n    @Input('ssSortableChildren') children?: Iterable<Data>;\n    /** Possible values:\n     *\n     * - 'halfway' (default): triggers a reorder when you drag halfway over a neighbour\n     * - 'fixed': triggers as soon as you move over a neighbouring element. Does not work with variable size elements. */\n    @Input('ssSortableTrigger') hoverTrigger = HoverTrigger.halfway;\n\n    /** @ignore */\n    private childrenSubject$ = new BehaviorSubject<Iterable<Data>>([]);\n    /**\n     * A handy way to subscribe to spec.getList().\n     */\n    public children$: Observable<Iterable<Data>> = this.childrenSubject$;\n\n    /** @ignore */\n    subs = new Subscription();\n    /** @ignore */\n    listSubs = new Subscription();\n\n    /** This DropTarget is attached to the whole list.\n     *\n     * You may monitor it for information like 'is an item hovering over this entire list somewhere?'\n     */\n    target: DropTarget<DraggedItem<Data>>;\n\n    /** @ignore */\n    constructor(\n        protected dnd: SkyhookDndService,\n        protected el: ElementRef<HTMLElement>,\n        protected cdr: ChangeDetectorRef\n    ) {\n        this.target = this.dnd.dropTarget<DraggedItem<Data>>(\n            null,\n            {\n                canDrop: (monitor) => {\n                    if (!this.acceptsType(monitor.getItemType())) {\n                        return false;\n                    }\n                    const item = monitor.getItem();\n                    if (!item) {\n                        return false;\n                    }\n                    return this.getCanDrop(item, monitor);\n                },\n                drop: (monitor) => {\n                    const item = monitor.getItem();\n                    if (item && this.getCanDrop(item, monitor)) {\n                        this.spec &&\n                            this.spec.drop &&\n                            this.spec.drop(item, monitor);\n                    }\n                    return {};\n                },\n                hover: (monitor) => {\n                    const item = monitor.getItem();\n                    if (this.children && isEmpty(this.children) && item) {\n                        const canDrop = this.getCanDrop(item, monitor);\n                        if (canDrop && monitor.isOver({ shallow: true })) {\n                            this.callHover(item, monitor, {\n                                listId: this.listId,\n                                index: 0,\n                            });\n                        }\n                    }\n                },\n            },\n            this.subs\n        );\n    }\n\n    /** @ignore */\n    private updateSubscription() {\n        const anyListId =\n            typeof this.listId !== 'undefined' && this.listId !== null;\n        if (anyListId && this.spec) {\n            if (this.listSubs) {\n                this.subs.remove(this.listSubs);\n                this.listSubs.unsubscribe();\n            }\n\n            if (this.spec.getList) {\n                const cs$ = this.spec.getList(this.listId);\n                this.listSubs =\n                    cs$ &&\n                    cs$.subscribe((l) => {\n                        if (l) {\n                            this.childrenSubject$.next(l);\n                            this.children = l;\n                            this.cdr.markForCheck();\n                        }\n                    });\n\n                this.subs.add(this.listSubs);\n            }\n        }\n    }\n\n    public contextFor(data: Data, index: number): RenderContext<Data> {\n        return {\n            data,\n            index,\n            listId: this.listId,\n            spec: this.spec,\n            horizontal: this.horizontal,\n            hoverTrigger: this.hoverTrigger,\n        };\n    }\n\n    /** @ignore */\n    private getCanDrop(\n        item: DraggedItem<Data>,\n        monitor: DropTargetMonitor<DraggedItem<Data>>,\n        _default = true\n    ) {\n        if (this.spec && this.spec.canDrop) {\n            return this.spec.canDrop(item, monitor);\n        }\n        return _default;\n    }\n\n    /** @ignore */\n    private callHover(\n        item: DraggedItem<Data>,\n        monitor: DropTargetMonitor<DraggedItem<Data>>,\n        newHover?: { listId: any; index: number }\n    ) {\n        if (newHover) {\n            // mutate the object\n            item.hover = newHover;\n            // but also shallow clone so distinct from previous,\n            // useful if you rely on that for ngrx\n            item = { ...item };\n        }\n        this.spec && this.spec.hover && this.spec.hover(item, monitor);\n    }\n\n    /** @ignore */\n    ngOnInit() {\n        this.updateSubscription();\n        this.target.setTypes(this.getTargetType());\n    }\n\n    getTargetType() {\n        if (Array.isArray(this.spec.accepts)) {\n            return this.spec.accepts;\n        } else {\n            return this.spec.accepts || this.spec.type;\n        }\n    }\n\n    acceptsType(ty: string | symbol | null) {\n        if (ty == null) return false;\n        if (Array.isArray(this.spec.accepts)) {\n            const arr = this.spec.accepts as Array<string | symbol>;\n            return arr.indexOf(ty) !== -1;\n        } else {\n            let acc = this.getTargetType();\n            return ty == acc;\n        }\n    }\n\n    /** @ignore */\n    ngOnChanges({ spec, listId }: SimpleChanges) {\n        if (listId) {\n            this.updateSubscription();\n        }\n        if (spec) {\n            this.updateSubscription();\n        }\n        this.target.setTypes(this.getTargetType());\n    }\n\n    /** @ignore */\n    ngAfterViewInit() {\n        if (this.el) {\n            this.target.connectDropTarget(this.el.nativeElement);\n        } else {\n            throw new Error('ssSortable directive must have ElementRef');\n        }\n    }\n\n    /** @ignore */\n    ngOnDestroy() {\n        this.subs.unsubscribe();\n    }\n}\n","/** @ignore\n * Returns isEmpty, whether it's an immutable List or an array\n */\nexport function isEmpty(list: Iterable<any>): boolean {\n    for (let _ of list) {\n        return false;\n    }\n    return true;\n}\n\n","import { Directive } from \"@angular/core\";\nimport { RenderContext } from \"../types\";\n\nexport interface TemplateContext<Data> {\n    $implicit: RenderContext<Data>\n}\n\n@Directive({\n    selector: '[ssTemplate]'\n})\nexport class SkyhookSortableTemplate {\n}\n","import {\n    Component,\n    Input,\n    TemplateRef,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    OnDestroy,\n    OnChanges,\n    AfterViewInit,\n    AfterContentInit,\n    ElementRef,\n    QueryList,\n    SimpleChanges,\n    ContentChildren,\n} from '@angular/core';\nimport { SkyhookDndService } from '@rednax/core';\n// @ts-ignore\nimport { Observable, Subscription } from 'rxjs';\nimport { SkyhookSortableTemplate, TemplateContext } from './template.directive';\nimport { SkyhookSortable } from './sortable.directive';\n\n@Component({\n    selector: 'skyhook-sortable-list',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: `\n        <ng-container\n            *ngFor=\"let card of children; let i = index; trackBy: trackById\"\n        >\n            <ng-container\n                *ngTemplateOutlet=\"\n                    template;\n                    context: {\n                        $implicit: contextFor(card, i)\n                    }\n                \"\n            >\n            </ng-container>\n        </ng-container>\n    `,\n    styles: [\n        `\n            :host {\n                display: block;\n            }\n        `,\n    ],\n    // allow injecting the directive and getting the component\n    providers: [\n        {\n            provide: SkyhookSortable,\n            useExisting: SkyhookSortableList,\n        },\n    ],\n})\nexport class SkyhookSortableList<Data> extends SkyhookSortable<Data>\n    implements OnDestroy, OnChanges, AfterContentInit, AfterViewInit {\n    @Input('ssTemplate') template?: TemplateRef<TemplateContext<Data>>;\n\n    /** @ignore */\n    @ContentChildren(SkyhookSortableTemplate, {\n        read: TemplateRef,\n    })\n    set ssRenderTemplates(ql: QueryList<TemplateRef<TemplateContext<Data>>>) {\n        if (ql.length > 0) {\n            this.template = ql.first;\n        }\n    }\n\n    /** @ignore */\n    constructor(\n        dnd: SkyhookDndService,\n        el: ElementRef<HTMLElement>,\n        cdr: ChangeDetectorRef\n    ) {\n        super(dnd, el, cdr);\n    }\n\n    /** @ignore */\n    trackById = (_: number, data: Data) => {\n        return this.spec && this.spec.trackBy(data);\n    };\n\n    /** @ignore */\n    ngAfterContentInit() {\n        if (!this.template) {\n            throw new Error(\n                'You must provide a <ng-template cardTemplate> as a content child, or with [template]=\"myTemplateRef\"'\n            );\n        }\n    }\n\n    // forwarding lifecycle events is required until Ivy renderer\n\n    /** @ignore */\n    ngOnInit() {\n        super.ngOnInit();\n    }\n\n    /** @ignore */\n    ngAfterViewInit() {\n        super.ngAfterViewInit();\n    }\n\n    /** @ignore */\n    ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n    }\n\n    /** @ignore */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n    }\n}\n","import { HoverTrigger } from './types';\nimport { Offset } from '@rednax/core';\nimport { RenderContext, DraggedItem } from './types';\n\n//     ~ List ~\n// [\n//   [ index 0 ]\n//   [ index 1 ] <-- index 1 gets picked up\n//   [ index 2 ]\n// ]\n//\n// We want to emit a hover when:\n//   - the mouse moves over the top half of 0\n//   - the mouse moves over the bottom half of 2\n//\n// ,----------------------,\n// | target 0 top half    | => emits 0\n// |----------------------|\n// | target 0 bottom half | => computes 1, doesn't emit\n// '----------------------'\n// ,----------------------,\n// | target 1 (inert)     | => computes 1, doesn't emit\n// '----------------------'\n// ,----------------------,\n// | target 2 top half    | => computes 1, doesn't emit\n// |----------------------|\n// | target 2 bottom half | => emits 2\n// '----------------------'\n//\n\nexport function suggestHalfway<Data>(\n    ctx: RenderContext<Data>,\n    item: DraggedItem<Data>,\n    rect: DOMRect | ClientRect,\n    clientOffset: Offset\n) {\n    const { hover } = item;\n    const dim = ctx.horizontal\n        ? rect.width || rect.right - rect.left\n        : rect.height || rect.bottom - rect.top;\n    const start = ctx.horizontal ? rect.left : rect.top;\n    const targetCentre = start + dim / 2.0;\n    const mouse = ctx.horizontal ? clientOffset.x : clientOffset.y;\n    const topHalf = mouse < targetCentre;\n    let suggestedIndex: number;\n    if (ctx.listId === hover.listId) {\n        if (ctx.index < hover.index) {\n            suggestedIndex = topHalf ? ctx.index : ctx.index + 1;\n        } else {\n            suggestedIndex = topHalf ? ctx.index - 1 : ctx.index;\n        }\n    } else {\n        // first hover on a different list;\n        // there is no relevant hover.index to compare to\n        suggestedIndex = topHalf ? ctx.index : ctx.index + 1;\n    }\n    return suggestedIndex;\n}\n\nexport function suggestFixed<Data>(ctx: RenderContext<Data>) {\n    return ctx.index;\n}\n\nexport function getSuggester(trigger: HoverTrigger) {\n    switch (trigger) {\n        case HoverTrigger.fixed:\n            return suggestFixed;\n        default:\n            return suggestHalfway;\n    }\n}\n","import { Directive, Input, ElementRef, OnInit, OnDestroy } from '@angular/core';\nimport {\n    SkyhookDndService,\n    DragSource,\n    DropTarget,\n    DragSourceMonitor,\n    DropTargetMonitor,\n} from '@rednax/core';\nimport { DraggedItem, Size, RenderContext } from '../types';\nimport { Observable, Subscription } from 'rxjs';\nimport { getSuggester } from '../hoverTriggers';\n\n/** @ignore */\nconst _scheduleMicroTaskPolyfill: (f: () => void) => any =\n    requestAnimationFrame ||\n    webkitRequestAnimationFrame ||\n    ((f: () => void) => setTimeout(f, 0));\n\n@Directive({\n    selector: '[ssRender]',\n    exportAs: 'ssRender',\n})\nexport class SkyhookSortableRenderer<Data> implements OnInit, OnDestroy {\n    @Input('ssRender') context!: RenderContext<Data>;\n\n    get data() {\n        return this.context.data;\n    }\n    /** @ignore */\n    private get type() {\n        return this.context.spec && this.context.spec.type;\n    }\n    /** @ignore */\n    private get accepts() {\n        const spec = this.context.spec;\n        if (!spec) return [];\n        if (Array.isArray(spec.accepts)) {\n            return spec.accepts;\n        } else {\n            return spec.accepts || spec.type;\n        }\n    }\n    /** @ignore */\n    private get listId() {\n        return this.context.listId;\n    }\n    /** @ignore */\n    private get index() {\n        return this.context.index;\n    }\n\n    /** @ignore */\n    private get spec() {\n        return this.context.spec;\n    }\n\n    /** @ignore */\n    private subs = new Subscription();\n\n    /** This DropTarget is attached where [ssRender] is.\n     *\n     * It is responsible for triggering {@link SortableSpec.hover} when the place you are hovering changes.\n     */\n    target: DropTarget<DraggedItem<Data>>;\n\n    /** This DragSource is NOT attached for you.\n     *\n     *  You need to attach it yourself, by pulling #render=\"ssRender\", and applying [dragSource]=\"render.source\".\n     */\n    source: DragSource<DraggedItem<Data>>;\n\n    /**\n     * Shortcut for `this.source.listen(m => m.isDragging())`\n     *\n     */\n    isDragging$: Observable<boolean>;\n\n    /** @ignore */\n    constructor(\n        private dnd: SkyhookDndService,\n        private el: ElementRef<HTMLElement>\n    ) {\n        this.target = this.dnd.dropTarget<DraggedItem<Data>>(\n            null,\n            {\n                // this is a hover-only situation\n                canDrop: () => false,\n                hover: (monitor) => {\n                    this.hover(monitor);\n                },\n            },\n            this.subs\n        );\n\n        this.source = this.dnd.dragSource<DraggedItem<Data>>(\n            null,\n            {\n                canDrag: (monitor) => {\n                    return this.getCanDrag(monitor);\n                },\n                isDragging: (monitor) => {\n                    return this.isDragging(monitor.getItem());\n                },\n                beginDrag: (monitor) => {\n                    const item = this.createItem();\n\n                    // Chromium bug since 2016: if you modify styles or DOM\n                    // synchronously within 'dragstart' handler, Chrome fires\n                    // a 'dragend' immediately.\n                    //\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=674882\n                    // although recommended Promise.resolve().then() doesn't work.\n                    this.spec &&\n                        this.spec.beginDrag &&\n                        _scheduleMicroTaskPolyfill(() => {\n                            this.spec &&\n                                this.spec.beginDrag &&\n                                this.spec.beginDrag(item, monitor);\n                        });\n\n                    return item;\n                },\n                endDrag: (monitor) => {\n                    const item = monitor.getItem();\n                    if (item) {\n                        this.spec &&\n                            this.spec.endDrag &&\n                            this.spec.endDrag(item, monitor);\n                    }\n                },\n            },\n            this.subs\n        );\n\n        this.isDragging$ = this.source.listen((m) => m.isDragging());\n    }\n\n    /** @ignore */\n    private createItem(): DraggedItem<Data> {\n        return {\n            data: this.data,\n            index: this.index,\n            size: this.size(),\n            type: this.type,\n            isInternal: true,\n            listId: this.listId,\n            hover: {\n                index: this.index,\n                listId: this.listId,\n            },\n        };\n    }\n\n    /** @ignore */\n    private sameIds = (data: Data, other: DraggedItem<Data>) => {\n        return (\n            data &&\n            other.data &&\n            this.spec.trackBy(data) === this.spec.trackBy(other.data)\n        );\n    };\n\n    /** @ignore */\n    private getCanDrag(monitor: DragSourceMonitor<void, void>) {\n        if (this.spec && this.spec.canDrag) {\n            return this.spec.canDrag(this.data, this.listId, monitor);\n        }\n        return true;\n    }\n\n    /** @ignore */\n    private isDragging(item: DraggedItem<Data> | null) {\n        if (this.spec && this.spec.isDragging) {\n            return (item && this.spec.isDragging(this.data, item)) || false;\n        } else {\n            return (item && this.sameIds(this.data, item)) || false;\n        }\n    }\n\n    /** @ignore */\n    private hover(monitor: DropTargetMonitor<DraggedItem<Data>>): void {\n        const item = monitor.getItem();\n        const clientOffset = monitor.getClientOffset();\n        if (item == null || clientOffset == null) {\n            return;\n        }\n        // hovering on yourself should do nothing\n        if (\n            this.isDragging(item) &&\n            this.index === item.hover.index &&\n            this.listId === item.hover.listId\n        ) {\n            return;\n        }\n        const { hover } = item;\n        let suggester = getSuggester(this.context.hoverTrigger);\n        let suggestedIndex = suggester(\n            this.context,\n            item,\n            this.rect(),\n            clientOffset\n        );\n\n        // happens if you aren't implementing SortableSpec correctly.\n        if (suggestedIndex < 0) {\n            // console.warn('this.listId',this.listId, 'hover.listId', hover.listId)\n            // suggestedIndex = 0;\n            throw new Error(\n                '@rednax/sortable: Cannot move a card to an index < 0.'\n            );\n        }\n\n        // move the item if its new position is different\n        if (suggestedIndex !== hover.index || this.listId !== hover.listId) {\n            item.hover = {\n                index: suggestedIndex,\n                listId: this.listId,\n            };\n            if (\n                this.spec &&\n                this.spec.canDrop &&\n                !this.spec.canDrop(item, monitor)\n            ) {\n                return;\n            }\n            // shallow clone so library consumers don't mutate our items\n            this.spec &&\n                this.spec.hover &&\n                this.spec.hover(\n                    {\n                        ...item,\n                    },\n                    monitor\n                );\n        }\n    }\n\n    /** @ignore */\n    private rect() {\n        if (!this.el) {\n            throw new Error(\n                '@rednax/sortable: [ssRender] expected to be attached to a real DOM element'\n            );\n        }\n        const rect = (this.el.nativeElement as Element).getBoundingClientRect();\n        return rect;\n    }\n\n    /** @ignore */\n    private size() {\n        const rect = this.rect();\n        const width = rect.width || rect.right - rect.left;\n        const height = rect.height || rect.bottom - rect.top;\n        return new Size(width, height);\n    }\n\n    /** @ignore */\n    ngOnInit() {\n        this.target.setTypes(this.accepts);\n        this.source.setType(this.type);\n    }\n\n    /** @ignore */\n    ngAfterViewInit() {\n        if (this.el) {\n            this.target.connectDropTarget(this.el.nativeElement);\n        }\n    }\n\n    /** @ignore */\n    ngOnChanges() {\n        this.target.setTypes(this.accepts);\n        this.source.setType(this.type);\n    }\n\n    /** @ignore */\n    ngOnDestroy() {\n        this.subs.unsubscribe();\n    }\n}\n","import { SortableSpec, DraggedItem } from './types';\nimport { DropTargetMonitor, DragSourceMonitor } from '@rednax/core';\nimport { Observable } from 'rxjs';\n\nexport enum SortableEvents {\n    BeginDrag = 'BeginDrag',\n    Hover = 'Hover',\n    Drop = 'Drop',\n    EndDrag = 'EndDrag',\n}\n\nexport class BeginDragAction<AT, T> {\n    readonly event = SortableEvents.BeginDrag;\n    constructor(\n        public readonly type: AT,\n        public readonly item: DraggedItem<T>\n    ) {}\n}\n\nexport class HoverAction<AT, T> {\n    readonly event = SortableEvents.Hover;\n    constructor(\n        public readonly type: AT,\n        public readonly item: DraggedItem<T>\n    ) {}\n}\n\nexport class DropAction<AT, T> {\n    readonly event = SortableEvents.Drop;\n    constructor(\n        public readonly type: AT,\n        public readonly item: DraggedItem<T>\n    ) {}\n}\n\nexport class EndDragAction<AT, T> {\n    readonly event = SortableEvents.EndDrag;\n    constructor(\n        public readonly type: AT,\n        public readonly item: DraggedItem<T>\n    ) {}\n}\n\nexport type SortableAction<AT, D> =\n    | BeginDragAction<AT, D>\n    | HoverAction<AT, D>\n    | DropAction<AT, D>\n    | EndDragAction<AT, D>;\n\n/** Intended to be your NgRx Store object */\nexport interface Dispatcher {\n    dispatch: (action: SortableAction<any, any>) => void;\n}\n\nexport interface NgRxSortableConfiguration<D> {\n    type: string | symbol;\n    accepts?: string | symbol | (string | symbol)[];\n    trackBy: (data: D) => any;\n    getList: (listId: any) => Observable<Iterable<D>>;\n    canDrop?: (\n        item: DraggedItem<D>,\n        monitor: DropTargetMonitor<DraggedItem<D>>\n    ) => boolean;\n    canDrag?: (\n        data: D,\n        listId: any,\n        monitor: DragSourceMonitor<void, void>\n    ) => boolean;\n    isDragging?: (ground: D, inFlight: DraggedItem<D>) => boolean;\n    createData?: () => D;\n}\n\nexport class NgRxSortable<D> implements SortableSpec<D> {\n    public type!: string | symbol;\n    public accepts?: string | symbol | (string | symbol)[];\n    public trackBy!: (data: D) => any;\n    public getList!: (listId: any) => Observable<Iterable<D>>;\n    public canDrop?: (\n        item: DraggedItem<D>,\n        monitor: DropTargetMonitor<DraggedItem<D>>\n    ) => boolean;\n    public canDrag?: (\n        data: D,\n        listId: any,\n        monitor: DragSourceMonitor<void, void>\n    ) => boolean;\n    public isDragging?: (ground: D, inFlight: DraggedItem<D>) => boolean;\n    public createData?: () => D;\n\n    /**\n     * @param store      An @ngrx store instance.\n     * @param actionType The type in your own @ngrx/store `ActionTypes` enum you want the sortable actions to use.\n     * @param configure  You must provide `trackBy` and `getList` functions here. Hopefully your `getList` will select from the store you passed!\n     * */\n    constructor(\n        protected store: Dispatcher,\n        protected actionType: string,\n        configure: NgRxSortableConfiguration<D>\n    ) {\n        if (configure.type !== undefined) this.type = configure.type;\n        if (configure.accepts !== undefined) this.accepts = configure.accepts;\n        if (configure.trackBy !== undefined) this.trackBy = configure.trackBy;\n        if (configure.getList !== undefined) this.getList = configure.getList;\n        if (configure.canDrag !== undefined) this.canDrag = configure.canDrag;\n        if (configure.canDrop !== undefined) this.canDrop = configure.canDrop;\n        if (configure.isDragging !== undefined)\n            this.isDragging = configure.isDragging;\n        if (configure.createData !== undefined)\n            this.createData = configure.createData;\n    }\n\n    // We now implement the SortableSpec interface by dispatching actions\n\n    beginDrag = (\n        item: DraggedItem<D>,\n        _monitor: DragSourceMonitor<void, void>\n    ): void => {\n        this.store.dispatch(new BeginDragAction(this.actionType, item));\n    };\n    hover = (\n        item: DraggedItem<D>,\n        _monitor: DropTargetMonitor<DraggedItem<D>>\n    ): void => {\n        this.store.dispatch(new HoverAction(this.actionType, item));\n    };\n    drop = (\n        item: DraggedItem<D>,\n        _monitor: DropTargetMonitor<DraggedItem<D>>\n    ): void => {\n        this.store.dispatch(new DropAction(this.actionType, item));\n    };\n    endDrag = (\n        item: DraggedItem<D>,\n        _monitor: DragSourceMonitor<DraggedItem<D>>\n    ): void => {\n        this.store.dispatch(new EndDragAction(this.actionType, item));\n    };\n}\n","import {\n    Directive,\n    Input,\n    ElementRef,\n    OnChanges,\n    OnDestroy,\n} from '@angular/core';\nimport { SkyhookDndService, DragSource } from '@rednax/core';\nimport { DraggedItem, SortableSpec, Size } from '../types';\n// @ts-ignore\nimport { Observable, Subscription } from 'rxjs';\n\nexport const EXTERNAL_LIST_ID: symbol = Symbol('EXTERNAL_LIST_ID');\n\n@Directive({\n    selector: '[ssExternal]',\n    exportAs: 'ssExternal',\n})\nexport class SkyhookSortableExternal<Data> implements OnChanges, OnDestroy {\n    @Input('ssExternal') spec!: SortableSpec<Data>;\n\n    /** This source has beginDrag and endDrag implemented in line with what ssRender does.\n     *\n     * You must, like ssRender, attach it with [dragSource] somewhere.\n     */\n    public source: DragSource<DraggedItem<Data>>;\n\n    /** @ignore */\n    constructor(\n        private dnd: SkyhookDndService,\n        private el: ElementRef<Element>\n    ) {\n        this.source = this.dnd.dragSource<DraggedItem<Data>>(null, {\n            canDrag: (monitor) => {\n                if (this.spec && this.spec.canDrag) {\n                    // beginDrag has not been called yet, so there is no data, and this is not part of a list.\n                    // you should be able to decide canDrag without these anyway.\n                    return this.spec.canDrag(\n                        undefined as any,\n                        undefined,\n                        monitor\n                    );\n                }\n                return true;\n            },\n            beginDrag: () => {\n                if (typeof this.spec.createData !== 'function') {\n                    throw new Error('spec.createData must be a function');\n                }\n                return {\n                    type: this.spec.type,\n                    data: this.spec.createData(),\n                    hover: { index: -1, listId: EXTERNAL_LIST_ID },\n                    isInternal: false,\n                    index: -1,\n                    listId: EXTERNAL_LIST_ID,\n                    size: this.size(),\n                };\n            },\n            endDrag: (monitor) => {\n                const item = monitor.getItem();\n                if (item) {\n                    this.spec &&\n                        this.spec.endDrag &&\n                        this.spec.endDrag(item, monitor);\n                }\n            },\n        });\n    }\n\n    /** @ignore */\n    private size() {\n        const rect = this.el.nativeElement.getBoundingClientRect();\n        return new Size(\n            rect.width || rect.right - rect.left,\n            rect.height || rect.bottom - rect.top\n        );\n    }\n\n    /** @ignore */\n    ngOnChanges() {\n        this.source.setType(this.spec.type);\n    }\n    /** @ignore */\n    ngOnDestroy() {\n        this.source.unsubscribe();\n    }\n}\n","import { SkyhookDndService, DropTarget } from '@rednax/core';\nimport { DraggedItem } from './types';\nimport { Subject } from 'rxjs';\nimport { filter, distinctUntilChanged } from 'rxjs/operators';\n\nexport const SPILLED_LIST_ID: symbol = Symbol('SPILLED_LIST_ID');\n\nexport interface SpillConfiguration<Data> {\n    drop?: (item: DraggedItem<Data>) => void;\n    hover?: (item: DraggedItem<Data>) => void;\n}\n\nexport function spillTarget<Data>(\n    dnd: SkyhookDndService,\n    types: string | symbol | Array<string | symbol> | null,\n    config: SpillConfiguration<Data>\n): DropTarget<DraggedItem<Data>> {\n    const mutate = (item: DraggedItem<Data> | null) => {\n        if (!item) return null;\n        item.hover = { listId: SPILLED_LIST_ID, index: -1 };\n        return { ...item };\n    };\n\n    const hover$ = new Subject<DraggedItem<Data> | null>();\n\n    const target = dnd.dropTarget<DraggedItem<Data>>(types, {\n        hover: (monitor) => {\n            if (monitor.canDrop() && monitor.isOver({ shallow: true })) {\n                const item = mutate(monitor.getItem());\n                hover$.next(item);\n            } else {\n                hover$.next(null);\n            }\n        },\n        drop:\n            (config.drop &&\n                ((monitor) => {\n                    const item = mutate(monitor.getItem());\n                    if (!monitor.didDrop()) {\n                        config.drop && item && config.drop(item);\n                    }\n                })) ||\n            undefined,\n    });\n\n    const spilled$ = hover$.pipe(\n        distinctUntilChanged(),\n        filter((a) => !!a)\n    );\n\n    const subs = spilled$.subscribe((item) => {\n        config.hover && item && config.hover(item);\n    });\n\n    target.add(subs);\n    return target;\n}\n","import { NgModule } from '@angular/core';\nimport { SkyhookSortable } from './directives/sortable.directive';\nimport { SkyhookSortableList } from './directives/list.component';\nimport { SkyhookSortableTemplate } from './directives/template.directive';\nimport { SkyhookSortableRenderer } from './directives/render.directive';\nimport { SkyhookSortableExternal } from './directives/external.directive';\nimport { CommonModule } from '@angular/common';\nimport { SkyhookDndModule } from '@rednax/core';\n\n/** @ignore */\nconst EXPORTS = [\n    SkyhookSortable,\n    SkyhookSortableList,\n    SkyhookSortableTemplate,\n    SkyhookSortableRenderer,\n    SkyhookSortableExternal,\n];\n\n@NgModule({\n    declarations: EXPORTS,\n    exports: EXPORTS,\n    imports: [CommonModule, SkyhookDndModule],\n})\nexport class SkyhookSortableModule {}\n"]}