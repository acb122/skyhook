import { HoverTrigger } from './types';
//     ~ List ~
// [
//   [ index 0 ]
//   [ index 1 ] <-- index 1 gets picked up
//   [ index 2 ]
// ]
//
// We want to emit a hover when:
//   - the mouse moves over the top half of 0
//   - the mouse moves over the bottom half of 2
//
// ,----------------------,
// | target 0 top half    | => emits 0
// |----------------------|
// | target 0 bottom half | => computes 1, doesn't emit
// '----------------------'
// ,----------------------,
// | target 1 (inert)     | => computes 1, doesn't emit
// '----------------------'
// ,----------------------,
// | target 2 top half    | => computes 1, doesn't emit
// |----------------------|
// | target 2 bottom half | => emits 2
// '----------------------'
//
export function suggestHalfway(ctx, item, rect, clientOffset) {
    const { hover } = item;
    const dim = ctx.horizontal
        ? rect.width || rect.right - rect.left
        : rect.height || rect.bottom - rect.top;
    const start = ctx.horizontal ? rect.left : rect.top;
    const targetCentre = start + dim / 2.0;
    const mouse = ctx.horizontal ? clientOffset.x : clientOffset.y;
    const topHalf = mouse < targetCentre;
    let suggestedIndex;
    if (ctx.listId === hover.listId) {
        if (ctx.index < hover.index) {
            suggestedIndex = topHalf ? ctx.index : ctx.index + 1;
        }
        else {
            suggestedIndex = topHalf ? ctx.index - 1 : ctx.index;
        }
    }
    else {
        // first hover on a different list;
        // there is no relevant hover.index to compare to
        suggestedIndex = topHalf ? ctx.index : ctx.index + 1;
    }
    return suggestedIndex;
}
export function suggestFixed(ctx) {
    return ctx.index;
}
export function getSuggester(trigger) {
    switch (trigger) {
        case HoverTrigger.fixed:
            return suggestFixed;
        default:
            return suggestHalfway;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG92ZXJUcmlnZ2Vycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvc29ydGFibGUvc3JjL2xpYi9ob3ZlclRyaWdnZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFJdkMsZUFBZTtBQUNmLElBQUk7QUFDSixnQkFBZ0I7QUFDaEIsMkNBQTJDO0FBQzNDLGdCQUFnQjtBQUNoQixJQUFJO0FBQ0osRUFBRTtBQUNGLGdDQUFnQztBQUNoQyw2Q0FBNkM7QUFDN0MsZ0RBQWdEO0FBQ2hELEVBQUU7QUFDRiwyQkFBMkI7QUFDM0Isc0NBQXNDO0FBQ3RDLDJCQUEyQjtBQUMzQix1REFBdUQ7QUFDdkQsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQix1REFBdUQ7QUFDdkQsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQix1REFBdUQ7QUFDdkQsMkJBQTJCO0FBQzNCLHNDQUFzQztBQUN0QywyQkFBMkI7QUFDM0IsRUFBRTtBQUVGLE1BQU0sVUFBVSxjQUFjLENBQzFCLEdBQXdCLEVBQ3hCLElBQXVCLEVBQ3ZCLElBQTBCLEVBQzFCLFlBQW9CO0lBRXBCLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDdkIsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLFVBQVU7UUFDdEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSTtRQUN0QyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDNUMsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNwRCxNQUFNLFlBQVksR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUN2QyxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxZQUFZLENBQUM7SUFDckMsSUFBSSxjQUFzQixDQUFDO0lBQzNCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQzdCLElBQUksR0FBRyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFO1lBQ3pCLGNBQWMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1NBQ3hEO2FBQU07WUFDSCxjQUFjLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztTQUN4RDtLQUNKO1NBQU07UUFDSCxtQ0FBbUM7UUFDbkMsaURBQWlEO1FBQ2pELGNBQWMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQ3hEO0lBQ0QsT0FBTyxjQUFjLENBQUM7QUFDMUIsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZLENBQU8sR0FBd0I7SUFDdkQsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxNQUFNLFVBQVUsWUFBWSxDQUFDLE9BQXFCO0lBQzlDLFFBQVEsT0FBTyxFQUFFO1FBQ2IsS0FBSyxZQUFZLENBQUMsS0FBSztZQUNuQixPQUFPLFlBQVksQ0FBQztRQUN4QjtZQUNJLE9BQU8sY0FBYyxDQUFDO0tBQzdCO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhvdmVyVHJpZ2dlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgT2Zmc2V0IH0gZnJvbSAnQHJlZG5heC9jb3JlJztcbmltcG9ydCB7IFJlbmRlckNvbnRleHQsIERyYWdnZWRJdGVtIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vICAgICB+IExpc3QgflxuLy8gW1xuLy8gICBbIGluZGV4IDAgXVxuLy8gICBbIGluZGV4IDEgXSA8LS0gaW5kZXggMSBnZXRzIHBpY2tlZCB1cFxuLy8gICBbIGluZGV4IDIgXVxuLy8gXVxuLy9cbi8vIFdlIHdhbnQgdG8gZW1pdCBhIGhvdmVyIHdoZW46XG4vLyAgIC0gdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIHRvcCBoYWxmIG9mIDBcbi8vICAgLSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYm90dG9tIGhhbGYgb2YgMlxuLy9cbi8vICwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLFxuLy8gfCB0YXJnZXQgMCB0b3AgaGFsZiAgICB8ID0+IGVtaXRzIDBcbi8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuLy8gfCB0YXJnZXQgMCBib3R0b20gaGFsZiB8ID0+IGNvbXB1dGVzIDEsIGRvZXNuJ3QgZW1pdFxuLy8gJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4vLyAsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSxcbi8vIHwgdGFyZ2V0IDEgKGluZXJ0KSAgICAgfCA9PiBjb21wdXRlcyAxLCBkb2Vzbid0IGVtaXRcbi8vICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuLy8gLC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0sXG4vLyB8IHRhcmdldCAyIHRvcCBoYWxmICAgIHwgPT4gY29tcHV0ZXMgMSwgZG9lc24ndCBlbWl0XG4vLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbi8vIHwgdGFyZ2V0IDIgYm90dG9tIGhhbGYgfCA9PiBlbWl0cyAyXG4vLyAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSdcbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWdnZXN0SGFsZndheTxEYXRhPihcbiAgICBjdHg6IFJlbmRlckNvbnRleHQ8RGF0YT4sXG4gICAgaXRlbTogRHJhZ2dlZEl0ZW08RGF0YT4sXG4gICAgcmVjdDogRE9NUmVjdCB8IENsaWVudFJlY3QsXG4gICAgY2xpZW50T2Zmc2V0OiBPZmZzZXRcbikge1xuICAgIGNvbnN0IHsgaG92ZXIgfSA9IGl0ZW07XG4gICAgY29uc3QgZGltID0gY3R4Lmhvcml6b250YWxcbiAgICAgICAgPyByZWN0LndpZHRoIHx8IHJlY3QucmlnaHQgLSByZWN0LmxlZnRcbiAgICAgICAgOiByZWN0LmhlaWdodCB8fCByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgIGNvbnN0IHN0YXJ0ID0gY3R4Lmhvcml6b250YWwgPyByZWN0LmxlZnQgOiByZWN0LnRvcDtcbiAgICBjb25zdCB0YXJnZXRDZW50cmUgPSBzdGFydCArIGRpbSAvIDIuMDtcbiAgICBjb25zdCBtb3VzZSA9IGN0eC5ob3Jpem9udGFsID8gY2xpZW50T2Zmc2V0LnggOiBjbGllbnRPZmZzZXQueTtcbiAgICBjb25zdCB0b3BIYWxmID0gbW91c2UgPCB0YXJnZXRDZW50cmU7XG4gICAgbGV0IHN1Z2dlc3RlZEluZGV4OiBudW1iZXI7XG4gICAgaWYgKGN0eC5saXN0SWQgPT09IGhvdmVyLmxpc3RJZCkge1xuICAgICAgICBpZiAoY3R4LmluZGV4IDwgaG92ZXIuaW5kZXgpIHtcbiAgICAgICAgICAgIHN1Z2dlc3RlZEluZGV4ID0gdG9wSGFsZiA/IGN0eC5pbmRleCA6IGN0eC5pbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWdnZXN0ZWRJbmRleCA9IHRvcEhhbGYgPyBjdHguaW5kZXggLSAxIDogY3R4LmluZGV4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgaG92ZXIgb24gYSBkaWZmZXJlbnQgbGlzdDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gcmVsZXZhbnQgaG92ZXIuaW5kZXggdG8gY29tcGFyZSB0b1xuICAgICAgICBzdWdnZXN0ZWRJbmRleCA9IHRvcEhhbGYgPyBjdHguaW5kZXggOiBjdHguaW5kZXggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gc3VnZ2VzdGVkSW5kZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWdnZXN0Rml4ZWQ8RGF0YT4oY3R4OiBSZW5kZXJDb250ZXh0PERhdGE+KSB7XG4gICAgcmV0dXJuIGN0eC5pbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1Z2dlc3Rlcih0cmlnZ2VyOiBIb3ZlclRyaWdnZXIpIHtcbiAgICBzd2l0Y2ggKHRyaWdnZXIpIHtcbiAgICAgICAgY2FzZSBIb3ZlclRyaWdnZXIuZml4ZWQ6XG4gICAgICAgICAgICByZXR1cm4gc3VnZ2VzdEZpeGVkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3RIYWxmd2F5O1xuICAgIH1cbn1cbiJdfQ==